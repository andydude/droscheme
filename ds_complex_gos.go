//
// Droscheme - a Scheme implementation
// Copyright Â© 2012 Andrew Robbins
//
// This program is free software: it is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. You can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License (LGPL): <http://www.gnu.org/licenses/>.
//
// generated by gos2go from ds_complex.gos
package droscheme

import "math"

func _angle(z Any) Any {
	return z.(ComplexNum).Angle()
}
func _imagZKpart(z Any) Any {
	return z.(ComplexNum).Imag()
}
func _magnitude(z Any) Any {
	return z.(ComplexNum).Scale()
}
func _makeZKexactZKpolar(scale, angle Any) Any {
	s, t := UnifyAny(scale, angle)
	return SComplexPolar{ToRational(s), ToRational(t)}
}
func _makeZKinexactZKpolar(scale, angle Any) Any {
	s, t := UnifyFlonums(scale, angle)
	x := (s * math.Cos(t))
	y := (s * math.Sin(t))
	return Scomplex128(complex(x, y))
}
func _makeZKpolar(scale, angle Any) Any {
	if IsComplex(scale) || IsComplex(angle) {
		_error("make-polar expected real number")
	}
	if IsInexact(scale) || IsInexact(angle) {
		return _makeZKinexactZKpolar(scale, angle)
	}
	return _makeZKexactZKpolar(scale, angle)
}
func _makeZKexactZKrectangular(scale, angle Any) Any {
	s, t := UnifyAny(scale, angle)
	return SComplex{ToRational(s), ToRational(t)}
}
func _makeZKinexactZKrectangular(scale, angle Any) Any {
	s, t := UnifyFlonums(scale, angle)
	return Scomplex128(complex(s, t))
}
func _makeZKrectangular(x, y Any) Any {
	if IsComplex(x) || IsComplex(y) {
		_error("make-rectangular expected real number")
	}
	if IsInexact(x) || IsInexact(y) {
		return _makeZKinexactZKrectangular(x, y)
	}
	return _makeZKexactZKrectangular(x, y)
}
func _realZKpart(z Any) Any {
	return z.(ComplexNum).Real()
}
func Export_ds_complex(env *Env) {
	env.registerGos(_angle)
	env.registerGos(_imagZKpart)
	env.registerGos(_magnitude)
	env.registerGos(_makeZKexactZKpolar)
	env.registerGos(_makeZKinexactZKpolar)
	env.registerGos(_makeZKpolar)
	env.registerGos(_makeZKexactZKrectangular)
	env.registerGos(_makeZKinexactZKrectangular)
	env.registerGos(_makeZKrectangular)
	env.registerGos(_realZKpart)
}
