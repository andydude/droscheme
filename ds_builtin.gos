; -*- mode: scheme -*-
(package droscheme

  (define (any->go-string object)
    (void))

  (define (apply proc . args)
    (as proc Applier (Apply (vector->list (Vector args)))))

  (define (not bo)
    (not (as bo bool)))

  (define (bytevector-copy bv)
    (:= rv (make-bytevector (bytevector-length bv)))
    (bytevector-copy! bv rv)
    rv)

  (define (bytevector-length bv)
    (Sint64 (call-go len (as bv Binary))))

  ; nonstandard
  (define-go (bytevector (args (slice Any)) Any)
    (return (u8-vector->bytevector (Vector args))))

  (define (bytevector-u8-ref bv k)
    (as bv Binary (Ref k)))

  (define (bytevector-u8-set! bv k v)
    (as bv Binary (Set k v)))

  (define (bytevector->u8-list bv)
    bv)

  (define (bytevector->u8-vector ba)
    (:= bv (as ba Binary))
    (:= bl (call-go len bv))
    (:= rv (as (make-vector (Sint64 bl)) Binary))
    (for (:= i 0) (< i bl) (++ i)
         (= ((index rv i)) (index bv i)))
    rv)

  (define (open-input-file filename) (void))
  (define (open-output-file filename) (void))

  (define (call-with-values producer consumer)
    (:= values (as producer Applier (Apply (null))))
    (as consumer Applier (Apply values)))

  (define (command-line a)
    (void))

  ;(define (complex? a)
  ;  (Bool (_complexZS a)))

  (define (current-error-port . rest)
    (as gError Applier (Apply (vector->list (Vector rest)))))

  (define (current-input-port . rest)
    (as gInput Applier (Apply (vector->list (Vector rest)))))

  (define (current-output-port . rest)
    (as gOutput Applier (Apply (vector->list (Vector rest)))))

  (define (current-jiffy) (void))
  (define (current-second) (void))
  (define (denominator q)
    (as q SRational (Dmtr)))

  (define (display a . portZS)
    (:= port (index portZS 0))
    (as port OPort (Write (as (any->go-string a) String (ToBytes))))
    (void))

  (define (empty? a)
    (Bool (IsEmpty a)))

  (define (eof-object)
    gEOF)

  (define (eof-object? a)
    (if2 (:= (r ok) (as a Char)) ok
         (return (Bool (== r gEOF))))
    (Bool #f))

  (define (equal? a b)
    (void))

  (define (eval-rest exp env)
    (void))
          
  (define (eval exp env)
    (void))
          
  (define (exact-integer-sqrt a)
    (void))
          
  (define (exit a)
    (void))

  (define (floor a)
    (void))

  (define (flush-output-port port)
    (void))

  (define (get-output-bytevector port)
    (void))

  (define (get-output-string port)
    (void))

  (define (hash a)
    (void))
          
  (define (hashtable->list ht)
    (void))

  (define (hashtable-clear! ht)
    (void))

  (define (hashtable-contains? ht)
    (void))
  (define (hashtable-copy ht)
    (void))
  (define (hashtable-delete! ht)
    (void))
  (define (hashtable-entries ht)
    (void))
  (define (hashtable-equivalence-function ht)
    (void))
  (define (hashtable-hash-function ht)
    (void))
  (define (hashtable-keys ht)
    (void))
  (define (hashtable-mutable? ht)
    (void))
  (define (hashtable-ref ht)
    (void))
  (define (hashtable-set! ht)
    (void))
  (define (hashtable-size ht)
    (void))
  (define (hashtable-update! ht)
    (void))
  (define (hashtable-values ht)
    (void))
  (define (hashtable? ht)
    (void))

  ;(define (inexact=? z)
  ;  (void))
  ;(define (inexact? z)
  ;  (void))
  ;(define (input-port? port)
  ;  (Bool (_inputZKportZS port)))

  (define (integer->char z)
    (void))
  (define (integer? z)
    (void))
  (define (interaction-environment z)
    (void))

  (define (list->string z)
    (void))
  (define (make/ z)
    (void))
  (define (make-bytevector z)
    (void))
  (define (make-equal-hashtable z)
    (void))
  (define (make-hashtable z)
    (void))
  (define (make-parameter z)
    (void))
  (define (negative? x)
    (void))

  ;(define (newline . opt)
  ;  (apply (fn write) "\n" opt))

  (define (numerator q)
    (as q SRational (Nmtr)))

  (define (bytevector-copy! z y)
    (void))
  (define (u8-vector->bytevector z)
    (void))

;  (define (abs x)
;    (if (negative? x) (- x) x))

;  (define ( z)
;    (void))

;func DnumberZKtypeZKof(a Any) Any {
;    if ToFixnum(Dlength(list1(a))) == 2 {
;        x, _ := unlist2Number(a)
;        return NewSymbol(numberTypeToString(x.(BaseNum).GetNumberType()))
;    }
;    return NewSymbol(numberTypeToString(unlist1(a).(BaseNum).GetNumberType()))
;}
;  (define-go (number-type-code-of (a Any) int))

  ;(define-go (number-type-of (a Any) string)
  ;  (return (number-type-code->string (number-type-code-of a))))

;  (define-func (type-of (a Any) string)
;    (return (type-code->string (type-code-of a))))

;
;func DtypeZQZS(a Any) Any {
;    b, c := unlist2(a)
;    return Bool(b.(AnyKinder).GetType() == c.(AnyKinder).GetType())
;}

);package
