- Ledgend:
  []      -- means TODO
  [?]     -- means partial implementation
  [X]     -- means done! (please remove from this file)
  [C]     -- means control flow related, see below
  [S]     -- means syntax-rules related
  [D]     -- means syntax-rules dependant
  [L]     -- means define-library related
  [R]     -- means research

- Numbers
  [X] arithmetic functions
  [?] trigonometric functions, TODO: must accept integers
  [?] type promotion [AJR]
  [?] number->string, TODO: optional parameters
  [] inexact->exact
  [] exact->inexact
  ---
  [] test suite [AJR]

- Syntax
  [?] (define-syntax)
  [] (let-syntax)
  [] (letrec-syntax)
  [?] syntax-error, TODO: differentiate from (error)
  [] (syntax-rules)
  [] (syntax-case) -- low priority
  ---
  [X] Label these as [S] for syntax or [D] for dependant on syntax-rules
  [] research
  [] see if (define-record-type) can be derived syntax
  [] see if (parameterize) can be derived syntax

- Control flow
  [] (call/cc)
  [] (dynamic-wind)
  [] (guard)
  [] (with-exception-handler)
  ---
  [X] Label these as [C] for control
  [] research

- Library support
  [] cond-expand
  [] define-library (R7RS)
  [] library (R6RS)
  [] import -- for programs
  ---
  [X] Label these as [L] for library
  [] research snow
  [] parameterize

- Record support
  [] define-record-type
  ---
  [] test suite

- Hash Tables (from R6RS, and perhaps R7RS-large)
  [?] hashtable-mutable?, TODO: immutability
  [] list->hashtable -- equal? based
  [] vector->hashtable -- equal? based
  [] test suite [AJR]

- (scheme base) R7RS
  If you don't see the function here, then it means 
  that it's been implemented completely
  [D] and -- requires syntax-rules
  [C] call/cc
  [X] call/ec
  [D] case -- requires syntax-rules
  [D] case-lambda -- requires syntax-rules
  [D] cond -- requires syntax-rules
  [L] cond-expand
  [R] define-record-type
  [S] define-syntax
  [L] define-library/library
  [X] define-values
  [D] do
  [C] dynamic-wind
  [X] exact-integer-sqrt -- depends on rationalize
  [X] exact-integer?
  [C] guard
  [X] integer->char
  [L] import -- for programs
  [X] let
  [D] let loop -- requires syntax-rules
  [X] let*
  [D] let*-values -- requires syntax-rules
  [S] let-syntax
  [D] let-values -- requires syntax-rules
  [D] letrec -- requires syntax-rules
  [D] letrec* -- requires syntax-rules
  [S] letrec-syntax
  [D] or -- requires syntax-rules
  [R] parameterize
  [X] raise
  [?] raise-continuable -- may be revisited
  [X] rationalize
  [S] syntax-rules -- URGENT
  [D] unless -- requires syntax-rules
  [D] when -- requires syntax-rules
  [C] with-exception-handler
  [D] zero? -- requires case

- Other
  [] make Seq interface
  [] remove Equal() method
  [] remove GetType() method

- List of dependancies

zero? : cond
eq? : eqv?
eqv? : cond
cond : syntax-rules
fold-left : case-lambda
fold-right : case-lambda
case-lambda : syntax-rules
case : syntax-rules
and : syntax-rules
or : syntax-rules
when : syntax-rules
unless : syntax-rules

- Macros

(and #t (begin (display "hello") #t))
(and #t (begin (display "hello") #f))
(and #f (begin (display "hello") #t))
(and #f (begin (display "hello") #f))

(define-macro (and . rest)
  `(if (null? (list ,@rest)) #t
       (if (car (list ,@rest))
           (and ,@(cdr (list ,@rest)))
           #f)))

(define-macro (or . rest)
  `(if (null? (list ,@rest)) #f
       (if (car (list ,@rest))
           #t
           (or ,@(cdr (list ,@rest))))))

