- Ledgend:
  []      -- means TODO
  [?]     -- means partial implementation
  [X]     -- means done! (please remove from this file)
  [C]     -- means control flow related, see below
  [S]     -- means syntax-rules related
  [D]     -- means syntax-rules dependant
  [L]     -- means define-library related
  [R]     -- means research

- Numbers
  [X] arithmetic functions
  [?] trigonometric functions, TODO: must accept integers
  [?] type promotion [AJR]
  [?] number->string, TODO: optional parameters
  [] inexact->exact
  [] exact->inexact
  ---
  [] test suite [AJR]

- Syntax
  [?] (define-syntax)
  [] (let-syntax)
  [] (letrec-syntax)
  [?] syntax-error, TODO: differentiate from (error)
  [] (syntax-rules)
  [] (syntax-case) -- low priority
  ---
  [X] Label these as [S] for syntax or [D] for dependant on syntax-rules
  [] research
  [] see if (define-record-type) can be derived syntax
  [] see if (parameterize) can be derived syntax

- Control flow
  [] (call/cc)
  [] (dynamic-wind)
  [] (guard)
  [] (with-exception-handler)
  ---
  [X] Label these as [C] for control
  [] research

- Library support
  [] cond-expand
  [] define-library (R7RS)
  [] library (R6RS)
  [] import -- for programs
  ---
  [X] Label these as [L] for library
  [] research snow
  [] parameterize

- Record support
  [] define-record-type
  ---
  [] test suite

- Hash Tables (from R6RS, and perhaps R7RS-large)
  [X] hashtable-clear!
  [X] hashtable-contains?
  [?] hashtable-copy, TODO: immutability
  [X] hashtable-delete!
  [X] hashtable-entries
  [X] hashtable-equivalence-function
  [X] hashtable-hash-function
  [X] hashtable-keys
  [?] hashtable-mutable?, TODO: immutability
  [X] hashtable-ref
  [X] hashtable-set!
  [X] hashtable-size
  [X] hashtable-update!
  [X] hashtable?
  [X] hashtable->list
  [X] hashtable->vector
  [] list->hashtable -- equal? based
  [] vector->hashtable -- equal? based
  [] test suite [AJR]

- (scheme base) R7RS
  If you don't see the function here, then it means 
  that it's been implemented completely
  [D] and -- requires syntax-rules
  [C] call/cc
  [X] call/ec
  [D] case -- requires syntax-rules
  [D] case-lambda -- requires syntax-rules
  [D] cond -- requires syntax-rules
  [L] cond-expand
  [R] define-record-type
  [S] define-syntax
  [L] define-library/library
  [X] define-values
  [D] do
  [C] dynamic-wind
  [X] eof-object
  [X] eof-object?
  [X] error
  [X] error-object-irritants
  [X] error-object-message
  [X] error-object?
  [X] exact-integer-sqrt -- depends on rationalize
  [X] exact-integer?
  [X] floor
  [X] flush-output-port
  [X] gcd
  [X] get-output-bytevector
  [X] get-output-string
  [C] guard
  [X] integer->char
  [L] import -- for programs
  [X] lambda
  [X] lcm
  [X] let
  [D] let loop -- requires syntax-rules
  [X] let*
  [D] let*-values -- requires syntax-rules
  [S] let-syntax
  [D] let-values -- requires syntax-rules
  [D] letrec -- requires syntax-rules
  [D] letrec* -- requires syntax-rules
  [S] letrec-syntax
  [X] make-bytevector
  [X] make-list
  [X] make-parameter
  [X] make-string
  [X] make-vector
  [X] max
  [X] min
  [X] newline
  [X] open-binary-input-file
  [X] open-binary-output-file
  [X] open-input-file
  [X] open-input-bytevector
  [X] open-input-string
  [X] open-output-file
  [X] open-output-bytevector
  [X] open-output-string
  [D] or -- requires syntax-rules
  [R] parameterize
  [X] peek-char
  [X] peek-u8
  [X] port-open?
  [X] raise
  [?] raise-continuable -- may be revisited
  [] rationalize
  [X] read-bytevector
  [X] read-bytevector!
  [X] read-char
  [X] read-line
  [X] read-u8
  [X] reverse
  [X] round
  [X] set!
  [X] set-car!
  [X] set-cdr!
  [X] string->list
  [X] string->number
  [X] string->symbol
  [X] substring
  [X] symbol->string
  [S] syntax-rules -- URGENT
  [D] unless -- requires syntax-rules
  [D] when -- requires syntax-rules
  [C] with-exception-handler
  [X] write-bytevector
  [X] write-char
  [X] write-partial-bytevector
  [X] write-u8
  [D] zero? -- requires case

- Other
  [] make Seq interface
  [] remove Equal() method
  [] remove GetType() method

- List of dependancies

zero? : cond
eq? : eqv?
eqv? : cond
cond : syntax-rules
fold-left : case-lambda
fold-right : case-lambda
case-lambda : syntax-rules
case : syntax-rules
and : syntax-rules
or : syntax-rules
when : syntax-rules
unless : syntax-rules

- Macros

(and #t (begin (display "hello") #t))
(and #t (begin (display "hello") #f))
(and #f (begin (display "hello") #t))
(and #f (begin (display "hello") #f))

(define-macro (and . rest)
  `(if (null? (list ,@rest)) #t
       (if (car (list ,@rest))
           (and ,@(cdr (list ,@rest)))
           #f)))

(define-macro (or . rest)
  `(if (null? (list ,@rest)) #f
       (if (car (list ,@rest))
           #t
           (or ,@(cdr (list ,@rest))))))

