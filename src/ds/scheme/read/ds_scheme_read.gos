(go:package
  ds_scheme_read
  (go:import
    "ds/any"
    "ds/any/error"
    "ds/port"
    "ds/scheme/parameter")
  (go:var
    (go:= _ds_any ((go:dot ds_any Export)))
    (go:= append
          (go:as (go:index _ds_any "append")
                 (go:func
                   (#(a go:any) #(rest (go:ellipsis go:any)))
                   go:any)))
    (go:= apply
          (go:as (go:index _ds_any "apply")
                 (go:func
                   (#(proc go:any) #(args (go:ellipsis go:any)))
                   go:any)))
    (go:= apply-list
          (go:as (go:index _ds_any "apply-list")
                 (go:func (#(proc go:any) #(args go:any)) go:any)))
    (go:= apply-vector
          (go:as (go:index _ds_any "apply-vector")
                 (go:func (#(proc go:any) #(args go:any)) go:any)))
    (go:= primitive-apply-vector
          (go:as (go:index _ds_any "primitive-apply-vector")
                 (go:func (#(proc go:any) #(args go:any)) go:any)))
    (go:= boolean-and
          (go:as (go:index _ds_any "boolean-and")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= boolean-or
          (go:as (go:index _ds_any "boolean-or")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= boolean=?
          (go:as (go:index _ds_any "boolean=?")
                 (go:func (#(a go:any) #(b go:any)) go:any)))
    (go:= boolean?
          (go:as (go:index _ds_any "boolean?")
                 (go:func (#(a go:any)) go:any)))
    (go:= boolean
          (go:as (go:index _ds_any "boolean")
                 (go:func (#(a go:any)) go:any)))
    (go:= bytevector->u8-list
          (go:as (go:index _ds_any "bytevector->u8-list")
                 (go:func (#(a go:any)) go:any)))
    (go:= bytevector->u8-vector
          (go:as (go:index _ds_any "bytevector->u8-vector")
                 (go:func (#(a go:any)) go:any)))
    (go:= bytevector?
          (go:as (go:index _ds_any "bytevector?")
                 (go:func (#(a go:any)) go:any)))
    (go:= call
          (go:as (go:index _ds_any "call")
                 (go:func
                   (#(proc go:any) #(rest (go:ellipsis go:any)))
                   go:any)))
    (go:= car
          (go:as (go:index _ds_any "car")
                 (go:func (#(a go:any)) go:any)))
    (go:= cdr
          (go:as (go:index _ds_any "cdr")
                 (go:func (#(a go:any)) go:any)))
    (go:= cons
          (go:as (go:index _ds_any "cons")
                 (go:func (#(a go:any) #(b go:any)) go:any)))
    (go:= eof-object
          (go:as (go:index _ds_any "eof-object")
                 (go:func () go:any)))
    (go:= eof-object?
          (go:as (go:index _ds_any "eof-object?")
                 (go:func (#(a go:any)) go:any)))
    (go:= equal?
          (go:as (go:index _ds_any "equal?")
                 (go:func (#(a go:any) #(b go:any)) go:any)))
    (go:= append!
          (go:as (go:index _ds_any "append!")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= cdrs
          (go:as (go:index _ds_any "cdrs")
                 (go:func (#(lists go:any)) go:any)))
    (go:= cars
          (go:as (go:index _ds_any "cars")
                 (go:func (#(lists go:any)) go:any)))
    (go:= cars+
          (go:as (go:index _ds_any "cars+")
                 (go:func
                   (#(lists go:any) #(last-elt go:any))
                   go:any)))
    (go:= fold-right
          (go:as (go:index _ds_any "fold-right")
                 (go:func
                   (#(kons go:any)
                    #(knil go:any)
                    #(lis1 go:any)
                    #(lists (go:ellipsis go:any)))
                   go:any)))
    (go:= imm-list?
          (go:as (go:index _ds_any "imm-list?")
                 (go:func (#(a go:any)) go:any)))
    (go:= imm-null
          (go:as (go:index _ds_any "imm-null")
                 (go:func (#(o (go:ellipsis go:any))) go:any)))
    (go:= imm-null?
          (go:as (go:index _ds_any "imm-null?")
                 (go:func (#(a go:any)) go:any)))
    (go:= imm-pair?
          (go:as (go:index _ds_any "imm-pair?")
                 (go:func (#(a go:any)) go:any)))
    (go:= imm-star?
          (go:as (go:index _ds_any "imm-star?")
                 (go:func (#(a go:any)) go:any)))
    (go:= imm-star-length
          (go:as (go:index _ds_any "imm-star-length")
                 (go:func (#(a go:any)) go:any)))
    (go:= length
          (go:as (go:index _ds_any "length")
                 (go:func (#(ls go:any)) go:any)))
    (go:= list
          (go:as (go:index _ds_any "list")
                 (go:func (#(o (go:ellipsis go:any))) go:any)))
    (go:= list*
          (go:as (go:index _ds_any "list*")
                 (go:func (#(o (go:ellipsis go:any))) go:any)))
    (go:= list+
          (go:as (go:index _ds_any "list+")
                 (go:func
                   (#(first go:any) #(rest (go:ellipsis go:any)))
                   go:any)))
    (go:= list->string
          (go:as (go:index _ds_any "list->string")
                 (go:func (#(a go:any)) go:any)))
    (go:= list->vector
          (go:as (go:index _ds_any "list->vector")
                 (go:func (#(ls go:any)) go:any)))
    (go:= list?
          (go:as (go:index _ds_any "list?")
                 (go:func (#(a go:any)) go:any)))
    (go:= map1
          (go:as (go:index _ds_any "map1")
                 (go:func (#(proc go:any) #(ls go:any)) go:any)))
    (go:= map
          (go:as (go:index _ds_any "map")
                 (go:func
                   (#(proc go:any) #(rest (go:ellipsis go:any)))
                   go:any)))
    (go:= any1
          (go:as (go:index _ds_any "any1")
                 (go:func (#(pred go:any) #(ls go:any)) go:any)))
    (go:= any
          (go:as (go:index _ds_any "any")
                 (go:func
                   (#(pred go:any) #(rest (go:ellipsis go:any)))
                   go:any)))
    (go:= every1
          (go:as (go:index _ds_any "every1")
                 (go:func (#(pred go:any) #(ls go:any)) go:any)))
    (go:= every
          (go:as (go:index _ds_any "every")
                 (go:func
                   (#(pred go:any) #(rest (go:ellipsis go:any)))
                   go:any)))
    (go:= m-null?
          (go:as (go:index _ds_any "m-null?")
                 (go:func (#(a go:any)) go:any)))
    (go:= m-pair?
          (go:as (go:index _ds_any "m-pair?")
                 (go:func (#(a go:any)) go:any)))
    (go:= m-star?
          (go:as (go:index _ds_any "m-star?")
                 (go:func (#(a go:any)) go:any)))
    (go:= m-string?
          (go:as (go:index _ds_any "m-string?")
                 (go:func (#(a go:any)) go:any)))
    (go:= make-bytevector
          (go:as (go:index _ds_any "make-bytevector")
                 (go:func (#(k go:any)) go:any)))
    (go:= make-environment
          (go:as (go:index _ds_any "make-environment")
                 (go:func () go:any)))
    (go:= make-string
          (go:as (go:index _ds_any "make-string")
                 (go:func (#(k go:any)) go:any)))
    (go:= make-vector
          (go:as (go:index _ds_any "make-vector")
                 (go:func (#(k go:any)) go:any)))
    (go:= not
          (go:as (go:index _ds_any "not")
                 (go:func (#(a go:any)) go:any)))
    (go:= null
          (go:as (go:index _ds_any "null")
                 (go:func (#(o (go:ellipsis go:any))) go:any)))
    (go:= null?
          (go:as (go:index _ds_any "null?")
                 (go:func (#(a go:any)) go:any)))
    (go:= object-equal?
          (go:as (go:index _ds_any "object-equal?")
                 (go:func (#(a go:any) #(b go:any)) go:any)))
    (go:= pair?
          (go:as (go:index _ds_any "pair?")
                 (go:func (#(a go:any)) go:any)))
    (go:= s8?
          (go:as (go:index _ds_any "s8?")
                 (go:func (#(a go:any)) go:any)))
    (go:= s16?
          (go:as (go:index _ds_any "s16?")
                 (go:func (#(a go:any)) go:any)))
    (go:= s32?
          (go:as (go:index _ds_any "s32?")
                 (go:func (#(a go:any)) go:any)))
    (go:= s64?
          (go:as (go:index _ds_any "s64?")
                 (go:func (#(a go:any)) go:any)))
    (go:= string-append
          (go:as (go:index _ds_any "string-append")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= imm-string->string
          (go:as (go:index _ds_any "imm-string->string")
                 (go:func (#(str go:any)) go:any)))
    (go:= string->imm-string
          (go:as (go:index _ds_any "string->imm-string")
                 (go:func (#(str go:any)) go:any)))
    (go:= symbol->string
          (go:as (go:index _ds_any "symbol->string")
                 (go:func (#(a go:any)) go:any)))
    (go:= symbol=?
          (go:as (go:index _ds_any "symbol=?")
                 (go:func (#(a go:any) #(b go:any)) go:any)))
    (go:= symbol?
          (go:as (go:index _ds_any "symbol?")
                 (go:func (#(a go:any)) go:any)))
    (go:= type-check
          (go:as (go:index _ds_any "type-check")
                 (go:func
                   (#(expected go:any) #(irrs (go:ellipsis go:any)))
                   go:any)))
    (go:= type-error
          (go:as (go:index _ds_any "type-error")
                 (go:func
                   (#(expected go:any) #(irr go:any))
                   go:any)))
    (go:= u8-list->bytevector
          (go:as (go:index _ds_any "u8-list->bytevector")
                 (go:func (#(a go:any)) go:any)))
    (go:= u8-vector->bytevector
          (go:as (go:index _ds_any "u8-vector->bytevector")
                 (go:func (#(a go:any)) go:any)))
    (go:= u8?
          (go:as (go:index _ds_any "u8?")
                 (go:func (#(a go:any)) go:any)))
    (go:= u16?
          (go:as (go:index _ds_any "u16?")
                 (go:func (#(a go:any)) go:any)))
    (go:= u32?
          (go:as (go:index _ds_any "u32?")
                 (go:func (#(a go:any)) go:any)))
    (go:= u64?
          (go:as (go:index _ds_any "u64?")
                 (go:func (#(a go:any)) go:any)))
    (go:= vector
          (go:as (go:index _ds_any "vector")
                 (go:func (#(o (go:ellipsis go:any))) go:any)))
    (go:= vector->list
          (go:as (go:index _ds_any "vector->list")
                 (go:func (#(a go:any)) go:any)))
    (go:= vector->string
          (go:as (go:index _ds_any "vector->string")
                 (go:func (#(a go:any)) go:any)))
    (go:= vector-length
          (go:as (go:index _ds_any "vector-length")
                 (go:func (#(vc go:any)) go:any)))
    (go:= vector-map
          (go:as (go:index _ds_any "vector-map")
                 (go:func (#(proc go:any) #(vc go:any)) go:any)))
    (go:= vector?
          (go:as (go:index _ds_any "vector?")
                 (go:func (#(a go:any)) go:any)))
    (go:= void
          (go:as (go:index _ds_any "void")
                 (go:func () go:any)))
    (go:= void?
          (go:as (go:index _ds_any "void?")
                 (go:func (#(a go:any)) go:any)))
    (go:= ->imm-string
          (go:as (go:index _ds_any "->imm-string")
                 (go:func (#(str go:any)) go:any)))
    (go:= ->scheme-string
          (go:as (go:index _ds_any "->scheme-string")
                 (go:func (#(a go:any)) go:any)))
    (go:= ->string
          (go:as (go:index _ds_any "->string")
                 (go:func (#(str go:any)) go:any)))
    (go:= _ds_any_error
          ((go:dot ds_any_error Export)))
    (go:= make-error-object
          (go:as (go:index _ds_any_error "make-error-object")
                 (go:func
                   (#(msg go:any) #(irrs (go:ellipsis go:any)))
                   go:any)))
    (go:= error-object?
          (go:as (go:index _ds_any_error "error-object?")
                 (go:func (#(obj go:any)) go:any)))
    (go:= error-object-message
          (go:as (go:index _ds_any_error "error-object-message")
                 (go:func (#(obj go:any)) go:any)))
    (go:= error-object-irritants
          (go:as (go:index _ds_any_error "error-object-irritants")
                 (go:func (#(obj go:any)) go:any)))
    (go:= error
          (go:as (go:index _ds_any_error "error")
                 (go:func
                   (#(msg go:any) #(irrs (go:ellipsis go:any)))
                   go:any)))
    (go:= raise
          (go:as (go:index _ds_any_error "raise")
                 (go:func (#(obj go:any)) go:any)))
    (go:= raise-continuable
          (go:as (go:index _ds_any_error "raise-continuable")
                 (go:func (#(obj go:any)) go:any)))
    (go:= _ds_port ((go:dot ds_port Export)))
    (go:= standard-error-port
          (go:as (go:index _ds_port "standard-error-port")
                 (go:func () go:any)))
    (go:= standard-input-port
          (go:as (go:index _ds_port "standard-input-port")
                 (go:func () go:any)))
    (go:= standard-output-port
          (go:as (go:index _ds_port "standard-output-port")
                 (go:func () go:any)))
    (go:= open-binary-input-file
          (go:as (go:index _ds_port "open-binary-input-file")
                 (go:func
                   (#(filename go:any) #(fileopt go:any))
                   go:any)))
    (go:= open-binary-output-file
          (go:as (go:index _ds_port "open-binary-output-file")
                 (go:func
                   (#(filename go:any) #(fileopt go:any))
                   go:any)))
    (go:= open-input-file
          (go:as (go:index _ds_port "open-input-file")
                 (go:func
                   (#(filename go:any) #(opt (go:ellipsis go:any)))
                   go:any)))
    (go:= open-output-file
          (go:as (go:index _ds_port "open-output-file")
                 (go:func
                   (#(filename go:any) #(opt (go:ellipsis go:any)))
                   go:any)))
    (go:= port?
          (go:as (go:index _ds_port "port?")
                 (go:func (#(a go:any)) go:any)))
    (go:= binary-port?
          (go:as (go:index _ds_port "binary-port?")
                 (go:func (#(a go:any)) go:any)))
    (go:= textual-port?
          (go:as (go:index _ds_port "textual-port?")
                 (go:func (#(a go:any)) go:any)))
    (go:= output-port?
          (go:as (go:index _ds_port "output-port?")
                 (go:func (#(a go:any)) go:any)))
    (go:= input-port?
          (go:as (go:index _ds_port "input-port?")
                 (go:func (#(a go:any)) go:any)))
    (go:= _ds_scheme_parameter
          ((go:dot ds_scheme_parameter Export)))
    (go:= command-line
          (go:as (go:index _ds_scheme_parameter "command-line")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= current-error-port
          (go:as (go:index
                   _ds_scheme_parameter
                   "current-error-port")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= current-input-port
          (go:as (go:index
                   _ds_scheme_parameter
                   "current-input-port")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= current-output-port
          (go:as (go:index
                   _ds_scheme_parameter
                   "current-output-port")
                 (go:func (#(rest (go:ellipsis go:any))) go:any)))
    (go:= make-parameter
          (go:as (go:index _ds_scheme_parameter "make-parameter")
                 (go:func
                   (#(init go:any) #(conv go:any) #(name go:any))
                   go:any)))
    (go:= parameter-converter
          (go:as (go:index
                   _ds_scheme_parameter
                   "parameter-converter")
                 (go:func (#(param go:any)) go:any)))
    (go:= parameter-name
          (go:as (go:index _ds_scheme_parameter "parameter-name")
                 (go:func (#(param go:any)) go:any)))
    (go:= parameter-ref
          (go:as (go:index _ds_scheme_parameter "parameter-ref")
                 (go:func (#(param go:any)) go:any)))
    (go:= parameter-set!
          (go:as (go:index _ds_scheme_parameter "parameter-set!")
                 (go:func
                   (#(param go:any) #(value go:any))
                   go:any))))
  (go:func
    Export
    ()
    go:internal:frame
    (go:return
      (go:make:
        go:internal:frame
        (go:: "read-data" read-data)
        (go:: "read-lines" read-lines)
        (go:: "read" read))))
  (go:func
    read-lexer
    (#(lex (go:ptr Lexer)))
    (values #(value go:any) #(err go:error))
    (yyParse lex)
    (go:when
      (go:== lex.pcount 0)
      (go:= err lex.err)
      (go:else (go:= err gEOL)))
    (go:= value lex.value)
    (go:return))
  (go:func
    read-state
    (#(state State) #(port go:any))
    go:any
    (go::= (value err)
           (read-lexer
             (newLexerWithState
               (go:as port ds_port.TIPort)
               state)))
    (go:when (go:!= err go:nil) (go:panic err))
    (go:return value))
  (go:func
    read-data
    (#(port go:any))
    go:any
    (go:return (read port)))
  (go:func
    read-with-prompt
    (#(prompt go:any)
     #(port go:any)
     #(output-port go:any))
    go:any
    (go:return (read port)))
  (go:func
    read-expression
    (#(port go:any) #(prompt go:any))
    go:any
    (go:return ()))
  (go:func
    read-lines
    (#(port go:any))
    go:any
    (go:return
      (read-with-prompt
        "    "
        port
        (current-output-port))))
  (go:func
    read
    (#(port go:any))
    go:any
    (go::= (value err)
           (read-lexer
             (newLexer (go:as port ds_port.TIPort))))
    (go:when (go:!= err go:nil) (go:panic err))
    (go:return value)))
