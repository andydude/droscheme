define-library
 ds any runtime
 import "fmt" "reflect"
 begin

  (define (apply proc . args)
    (as proc Proc (Apply (Vector args))))

  (define (boolean? a)
    (:= (_ ok) (as a bool))
    ok)

  (define (boolean=? a b)
    (and (as (boolean? a) bool)
         (as (boolean? b) bool)
         (== (as a bool) (as b bool))))

  (define (bytevector . rest)
    (u8-vector->bytevector (Vector rest)))

  (define (bytevector->u8-list a)
    (vector->list (bytevector->u8-vector a)))

  (define (bytevector->u8-vector a)
    (:= bv (as a Binary))
    (:= vc (as (make-vector (call len bv)) Vector))
    (for (:= i 0) (< i (call len bv)) (++ i)
         (inline "vc[i] = bv[i]"))
    vc)
    
  (define (bytevector? a)
    (:= (_ ok) (as a Binary))
    ok)

  (define (car ls)
    (as ls (ptr Pair) car))

  (go:func car+cdr (ls) (car cdr)
    (return (car ls) (cdr ls)))

  (define (cdr ls)
    (as ls (ptr Pair) cdr))

  (define (char->integer ch)
    (call int (call rune (as ch Char))))

  (define (char=? a b)
    (== (as a Char) (as b Char)))

  (define (char? a)
    (:= (_ ok) (as a Char))
    ok)

  (define (cons a b)
    (adr #(Pair a b)))

  (define (eof-object)
    gEOF)
  
  (define (eof-object? a)
    (if2 (:= (ch ok) (as a Char)) ok
         (return (== ch gEOF)))
    #f)

  (define (eq? a b)
    (eqv? a b))

  (define (object-equal? a b)
    (dot reflect (DeepEqual a b)))

  (define (equal? a b)
    (if2 (:= (c ok) (as a Equaler)) ok
         (return (dot c (Equal b))))
    (if2 (:= (c ok) (as b Equaler)) ok
         (return (dot c (Equal a))))
    (object-equal? a b))

  (define (eqv? a b)
    (if1 (not (type=? a b)) (return #f))
    (if1 (symbol? a)  (return (symbol=? a b)))
    (if1 (boolean? a) (return (boolean=? a b)))
    (if1 (inexact? a) (return (inexact=? a b)))
    (if1 (exact? a)   (return (exact=? a b)))
    (if1 (char? a)    (return (char=? a b)))
    (if1 (null? a)    (return (null? b)))
    (if1 (empty? a)   (return (empty? b)))
    (pointer=? a b))

  ;; (error) is in error.go

  (define (error msg . irr)
    (raise (error-object msg (postellipsis irr))))

  (define (error-object msg . irr)
    (:= str (as (->imm-string msg) string))
    #(ErrorObject #:msg str #:it (Vector irr)))

  (define (error-object-irritants a)
    (as a Error (Irritants)))
          
  (define (error-object-message a)
    (as a Error (Error)))

  (define (error-object? a)
    (:= (_ ok) (as a Error))
    ok)

  (define (exact=? a b)
    (object-equal? a b))

  (define (exact? a)
    (if2 (:= (num ok) (as a Num)) ok
         (dot num (IsExact)))
    #f)

  (define (inexact=? a b)
    (object-equal? a b))

  (define (inexact? a)
    (if2 (:= (num ok) (as a Num)) ok
         (dot num (IsInexact)))
    #f)

  (define (integer->char cp)
    (call Char (call rune (as cp int))))

  (define (last-pair ls)
    (:= cur ls)
    (if1 (null? cur) (return (null)))
    (while (pair? (cdr cur))
           (= cur (cdr cur)))
    cur)

  (define (length ls)
    (if1 (null? ls)
         (return 0))
    (if2 (:= (_ ok) (as ls (ptr Pair))) ok
         (return (+ 1 (as (length (cdr ls)) int))))
    (error "length expected list"))

  (define (list* . o)
    (:= (most last) (inline "o[0:len(o) - 1], []Any(o[len(o) - 1].(Vector))"))
    (:= vs (call append most ((array-slice Any) (as (list->vector last) Vector))))
    (vector->list (Vector vs)))

  (define (list+ a . rest)
    (:= first ((array-slice Any) (as (list->vector a) Vector)))
    (vector->list (Vector (call append first (postellipsis rest)))))

  (define (list? a)
    (null? (cdr (last-pair a))))

  (define (list . o)
    (vector->list o))

  (define (list*->vector pr)
    (:= vec #((array-slice Any)))
    (define-var (:: cur Any))
    (for (= cur pr) (pair? (cdr cur)) (= cur (cdr cur))
         (= vec (call append vec (car cur))))
    (= vec (call append vec (car cur) (cdr cur)))
    (Vector vec))

  (define (list->string a)
    (vector->string (list->vector a)))

  (define (list->vector ls)
    (if1 (null? ls)
         (return (Vector #((array-slice Any)))))
    (if1 (not (pair? ls))
         (error "list->vector expected list"))
    (:= (cur vc) (null) #((array-slice Any)))
    (for (= cur ls) (pair? cur) (= cur (cdr cur))
         (= vc (call append vc (car cur))))
    (if1 (not (null? cur))
         (error "list->vector expected null"))
    (Vector vc))

  (define (make-bytevector k)
    (Binary (call make (array-slice byte) (as k int))))

  (define (make-list k)
    (vector->list (make-vector k)))

  (define (make-string k)
    (String (call make (array-slice rune) (as k int))))

  (define (make-vector k)
    (Vector (call make (array-slice Any) (as k int))))

  (define (not bl)
    (not (as bl bool)))

  (define (null . o)
    gNull)

  (define (null? a)
    (:= (_ ok) (as a (ptr Null)))
    ok)

  (go:func object-hash (obj)
    _object-hash
    (#(rest Any))
    Any
    (go:when
      (go:== (go:len rest) 1)
      (go:return
        ((go:dot (go:as (go:index rest 0) Hasher) GetHash))))
    (go::= hashport (crc32.NewIEEE))
    (go:for
      (go::= i 0)
      (go:< i (go:len rest))
      (go:++ i)
      (go::= code
             (_u32->bytevector
               (_object-hash (go:index rest i))))
      (go::= (_ err)
             (hashport.Write
               ((go:slice go:byte) (go:as code Binary))))
      (go:when (go:!= err go:nil) (go:panic err)))
    (go:return (go:uintptr (hashport.Sum32))))
 
  (define (pair? a)
    (:= (_ ok) (as a (ptr Pair)))
    ok)

  (define (pointer-of a)
    (dot reflect (ValueOf a) (Pointer)))

  (define (pointer=? a b)
    (== (as (pointer-of a) uintptr)
        (as (pointer-of b) uintptr)))

  (define (procedure? a)
    (:= (_ ok) (as a Proc))
    ok)

  (define (raise err)
    (call panic err)
    (void))

  (define (string . chars)
    (vector->string (Vector chars)))

  (define (string-hash a)
    (dot (NewString (as a string)) (GetHash)))

  (define (string->list a)
    (vector->list (string->vector a)))

  (define (string->vector a)
    (:= st (as a String))
    (:= vc (as (make-vector (call len st)) Vector))
    (for (:= i 0) (< i (call len st)) (++ i)
         (inline "vc[i] = st[i]"))
    vc)
    
  (define (string? a)
    (:= (_ ok) (as a String))
    ok)

  (define (symbol=? a b)
    (== (as a Symbol (String))
        (as b Symbol (String))))

  (define (string->symbol a)
    (as a String (ToSymbol)))

  (define (symbol->string a)
    (as a Symbol (ToString)))

  (define (symbol? a)
    (:= (_ ok) (as a Symbol))
    ok)

  (define (u8-list->bytevector a)
    (u8-vector->bytevector (list->vector a)))
    
  (define (u8-vector->bytevector a)
    (:= vc (as a Vector))
    (:= bv (as (make-bytevector (call len vc)) Binary))
    (for (:= i 0) (< i (call len vc)) (++ i)
         (inline "bv[i] = vc[i].(byte)"))
    bv)

  (define (u32->bytevector a)
    (go::= buf (new bytes.Buffer))
    (go::= err
           (binary.Write buf binary.LittleEndian a))
    (go:when (go:!= err go:nil) (go:panic err))
    (go:return (Binary (buf.Bytes)))))

  (define (vector->list* a)
    (:= vc (as a Vector))
    (if1 (== (call len vc) 0)
         (return (null)))
    (if1 (== (call len vc) 1)
         (return (index vc 0)))
    (cons (index vc 0) (vector->list* (Vector (index-slice vc 1)))))

  (define (vector->string a)
    (:= vc (as a Vector))
    (:= st (as (make-string (call len vc)) String))
    (for (:= i 0) (< i (call len vc)) (++ i)
         (inline "st[i] = rune(vc[i].(Char))"))
    st)
    
  (define (vector . o)
    (Vector o))

  (define (vector->list a)
    (:= (vc ls) (as a Vector) (null))
    (for (:= i (inline "len(vc) - 1")) (>= i 0) (-- i)
         (= ls (cons (inline "vc[i]") ls)))
    ls)

  (define (vector? a)
    (:= (_ ok) (as a Vector))
    ok)

  (define (void . o)
    gVoid)

  (define (void? a)
    (:= (_ ok) (as a (ptr Void)))
    ok)

  (define (u8? a)
    (if2 (:= (_ ok) (as a byte)) ok
         (return #t))
    (if2 (:= (c ok) (as a int)) (and ok (<= 0 c 255))
         (return #t))
    #f)

  (define (type=? a b)
    (== (as a AnyKinder (GetType))
        (as b AnyKinder (GetType))))

  (define (string->imm-string a)
    (if2 (:= (s ok) (as a String)) ok
         (return (dot s (String))))
    (error "expected string"))
    
  (define (imm-string->string a)
    (if2 (:= (s ok) (as a string)) ok
         (return (NewString s)))
    (error "expected imm-string"))

  (define (->go-string a)
    (if2 (:= (s ok) (as a GoStringer)) ok
         (return (dot s (GoString))))
    (error "->scheme-string unknown type"))

  (define (->imm-string a)
    (if2 (:= (s ok) (as a string)) ok
         (return s))
    (if2 (:= (s ok) (as a (dot fmt Stringer))) ok
         (return (dot s (String))))
    (error "->imm-string unknown type"))

  (define (->scheme-string a)
    (if2 (:= (s ok) (as a SchemeStringer)) ok
         (return (dot s (SchemeString))))
    (error "->scheme-string unknown type"))

  (define (->string a)
    (if2 (:= (s ok) (as a String)) ok
         (return s))
    (imm-string->string
      (->imm-string a)))
