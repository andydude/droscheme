
  ;(define (eval exp env)
  ;  (as exp Evaler (Eval (as env (ptr Env)))))
  ;(define (symbol=? a b)
  ;  (string=? (symbol->string a)
  ;            (symbol->string b)))
;  (define (open-input-file filename) (void))
;  (define (open-output-file filename) (void))
;  (define (call-with-values producer consumer)
;    (:= values (as producer Proc (Apply (null))))
;    (as consumer Proc (Apply values)))
  ;(define command-line (make-parameter (vector)))
  ;(define (command-line a)
  ;  (void))
;  ;(define (complex? a)
;  ;  (Bool (_complexZS a)))
;  (define (current-jiffy) (void))
;  (define (current-second) (void))
;  (define (denominator q)
;    (as q SRational (Dmtr)))
;
;  (define (display a . portZS)
;    (:= port (index portZS 0))
;    (as port OPort (Write (as (any->go-string a) String (ToBytes))))
;    (void))
;
;  (define (empty? a)
;    (Bool (IsEmpty a)))
;
;
;  (define (equal? a b)
;    (void))
;
;  (define (eval-rest exp env)
;    (void))
;
;  (define (eval exp env)
;    (void))
;
;  (define (exact-integer-sqrt a)
;    (void))
;
;  (define (exit a)
;    (void))
;
;  (define (floor a)
;    (void))
;
;  (define (flush-output-port port)
;    (void))
;
;  (define (get-output-bytevector port)
;    (void))
;
;  (define (get-output-string port)
;    (void))
;
;  (define (hash a)
;    (void))
;
;  (define (hashtable->list ht)
;    (void))
;
;  (define (hashtable-clear! ht)
;    (void))
;
;  (define (hashtable-contains? ht)
;    (void))
;  (define (hashtable-copy ht)
;    (void))
;  (define (hashtable-delete! ht)
;    (void))
;  (define (hashtable-entries ht)
;    (void))
;  (define (hashtable-equivalence-function ht)
;    (void))
;  (define (hashtable-hash-function ht)
;    (void))
;  (define (hashtable-keys ht)
;    (void))
;  (define (hashtable-mutable? ht)
;    (void))
;  (define (hashtable-ref ht)
;    (void))
;  (define (hashtable-set! ht)
;    (void))
;  (define (hashtable-size ht)
;    (void))
;  (define (hashtable-update! ht)
;    (void))
;  (define (hashtable-values ht)
;    (void))
;  (define (hashtable? ht)
;    (void))
;
;  ;(define (inexact=? z)
;  ;  (void))
;  ;(define (inexact? z)
;  ;  (void))
;  ;(define (input-port? port)
;  ;  (Bool (_inputZKportZS port)))
;
;  (define (integer->char z)
;    (void))
;  (define (integer? z)
;    (void))
;  (define (interaction-environment z)
;    (void))
;
;  (define (list->string z)
;    (void))
;  (define (make/ z)
;    (void))
;  (define (make-equal-hashtable z)
;    (void))
;  (define (make-hashtable z)
;    (void))
;  (define (make-parameter z)
;    (void))
;  (define (negative? x)
;    (void))
;
;  ;(define (newline . opt)
;  ;  (apply (fn write) "\n" opt))
;
;  (define (numerator q)
;    (as q SRational (Nmtr)))
;
;  (define (bytevector-copy! z y)
;    (void))
;  (define (u8-vector->bytevector z)
;    (void))

;  (define (abs x)
;    (if (negative? x) (- x) x))
;
;func DnumberZKtypeZKof(a Any) Any {
;    if ToFixnum(Dlength(list1(a))) == 2 {
;        x, _ := unlist2Number(a)
;        return NewSymbol(numberTypeToString(x.(BaseNum).GetNumberType()))
;    }
;    return NewSymbol(numberTypeToString(unlist1(a).(BaseNum).GetNumberType()))
;}
;(define-go (number-type-code-of (a Any) int))
;(define-go (number-type-of (a Any) string)
;  (return (number-type-code->string (number-type-code-of a))))
;  (define-func (type-of (a Any) string)
;    (return (type-code->string (type-code-of a))))
;
;func DtypeZQZS(a Any) Any {
;    b, c := unlist2(a)
;    return Bool(b.(AnyKinder).GetType() == c.(AnyKinder).GetType())
;}

 );begin
);library
