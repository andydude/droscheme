//
// Droscheme - a Scheme implementation
// Copyright Â© 2012 Andrew Robbins
//
// This program is free software: it is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. You can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License (LGPL): <http://www.gnu.org/licenses/>.
//
// generated by gos2go from ds_vector.gos
package droscheme
func _reverseZKlistZKZRvector() Any {
	return _void()
}
func _reverseZKvectorZKZRlist() Any {
	return _void()
}
func _vectorZKZRlistZH(z Any) Any {
	return false
}
func _listZHZKZRvector(z Any) Any {
	return false
}
func _listZKZRvector(ls Any) Any {
	if _nullZS(ls) {
		return Vector([]Any{})
	}
	if !_pairZS(ls) {
		_error("list->vector expected list")
	}
	cur, vc := _null(), []Any{}
	for cur = ls; _pairZS(cur); cur = _cdr(cur) {
		vc = append(vc, _cdr(cur))
	}
	if !_nullZS(cur) {
		_error("list->vector expected null")
	}
	return NewVector(vc)
}
func _vectorZKZRlist(vs Any) Any {
	vc, ls := vs.(Vector), _null()
	for i := len(vc) - 1; i >= 0; i-- {
		ls = _cons(vc[i], ls)
	}
	return ls
}
func _vector() Any {
	return _void()
}
func _vectorZKany() Any {
	return _void()
}
func _vectorZKappend() Any {
	return _void()
}
func _vectorZKbinaryZKsearch() Any {
	return _void()
}
func _vectorZKconcatenate() Any {
	return _void()
}
func _vectorZKcopyZA() Any {
	return _void()
}
func _vectorZKcopy() Any {
	return _void()
}
func _vectorZKcount() Any {
	return _void()
}
func _vectorZKemptyZS() Any {
	return _void()
}
func _vectorZKevery() Any {
	return _void()
}
func _vectorZKfillZA() Any {
	return _void()
}
func _vectorZKfold() Any {
	return _void()
}
func _vectorZKfoldZKright() Any {
	return _void()
}
func _vectorZKforZKeach() Any {
	return _void()
}
func _vectorZKindex() Any {
	return _void()
}
func _vectorZKindexZKright() Any {
	return _void()
}
func _vectorZKlength() Any {
	return _void()
}
func _vectorZKmapZA() Any {
	return _void()
}
func _vectorZKmap() Any {
	return _void()
}
func _makeZKvector(k Any) Any {
	return _void()
}
func _vectorZKref(vc, k Any) Any {
	return vc.(Vector).Ref(k)
}
func _vectorZKreverseZA() Any {
	return _void()
}
func _vectorZKreverseZKcopyZA() Any {
	return _void()
}
func _vectorZKreverseZKcopy() Any {
	return _void()
}
func _vectorZKsetZA() Any {
	return _void()
}
func _vectorZKskip() Any {
	return _void()
}
func _vectorZKskipZKright() Any {
	return _void()
}
func _vectorZKswapZA() Any {
	return _void()
}
func _vectorZKunfold() Any {
	return _void()
}
func _vectorZKunfoldZKright() Any {
	return _void()
}
func _vectorZS(object Any) Any {
	return Bool(IsVector(object))
}
func Export_ds_vector(env *Env) {
	env.registerGos(_reverseZKlistZKZRvector)
	env.registerGos(_reverseZKvectorZKZRlist)
	env.registerGos(_vectorZKZRlistZH)
	env.registerGos(_listZHZKZRvector)
	env.registerGos(_listZKZRvector)
	env.registerGos(_vectorZKZRlist)
	env.registerGos(_vector)
	env.registerGos(_vectorZKany)
	env.registerGos(_vectorZKappend)
	env.registerGos(_vectorZKbinaryZKsearch)
	env.registerGos(_vectorZKconcatenate)
	env.registerGos(_vectorZKcopyZA)
	env.registerGos(_vectorZKcopy)
	env.registerGos(_vectorZKcount)
	env.registerGos(_vectorZKemptyZS)
	env.registerGos(_vectorZKevery)
	env.registerGos(_vectorZKfillZA)
	env.registerGos(_vectorZKfold)
	env.registerGos(_vectorZKfoldZKright)
	env.registerGos(_vectorZKforZKeach)
	env.registerGos(_vectorZKindex)
	env.registerGos(_vectorZKindexZKright)
	env.registerGos(_vectorZKlength)
	env.registerGos(_vectorZKmapZA)
	env.registerGos(_vectorZKmap)
	env.registerGos(_makeZKvector)
	env.registerGos(_vectorZKref)
	env.registerGos(_vectorZKreverseZA)
	env.registerGos(_vectorZKreverseZKcopyZA)
	env.registerGos(_vectorZKreverseZKcopy)
	env.registerGos(_vectorZKsetZA)
	env.registerGos(_vectorZKskip)
	env.registerGos(_vectorZKskipZKright)
	env.registerGos(_vectorZKswapZA)
	env.registerGos(_vectorZKunfold)
	env.registerGos(_vectorZKunfoldZKright)
	env.registerGos(_vectorZS)
}
