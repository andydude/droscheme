(package main (import "fmt" "go/ast" "go/token") (func...  #(c (ptr Compiler)) emit ( #(format &imm-string) #(params (interface ))) &void  (apply... fmt.Fprintf c.wr format params)) (func  #(c (ptr Compiler)) emitRaw ( #(output &imm-string)) &void  (fmt.Fprint c.wr output)) (func  #(c (ptr Compiler)) emitArrayType ( #(node (ptr ast.ArrayType))) &void  (when (== node.Len %nil)  (c.emit "(slice ")(else (when* (:= (_ ok) (as node.Len (ptr ast.Ellipsis))) ok  (c.emit "(array... ")(else  (c.emit "(array ") (c.emitExpr node.Len) (c.emit " "))))) (c.emitType node.Elt) (c.emit ")")) (func  #(c (ptr Compiler)) emitAssignStmt ( #(node (ptr ast.AssignStmt))) &void  (c.emit "(%s " (goBinaryOpToSchemeOp ((dot node.Tok String)))) (:= sep "(") (when (== (len node.Lhs) 1)  (type! (:= a (as (index node.Lhs 0) type)) (((ptr ast.Ident))  (c.emitIdent a) (goto right)) (((ptr ast.SelectorExpr))  (c.emitSelectorExpr a) (goto right)))) (range (:= (_ expr) node.Lhs) (c.emit sep) (c.emitExpr expr) (= sep " ")) (c.emit ")") (label right (range (:= (_ expr) node.Rhs) (c.emit " ") (c.emitExpr expr))) (c.emit ")")) (func  #(c (ptr Compiler)) emitBasicLit ( #(node (ptr ast.BasicLit))) &void  (case! node.Kind ((token.CHAR)  (c.emit "#\\%s" (goCharToSchemeChar node))) ((token.STRING)  (c.emitRaw (goStringToSchemeString node))) (else  (c.emitRaw (goStringToSchemeString node))))) (func  #(c (ptr Compiler)) emitBinaryExpr ( #(node (ptr ast.BinaryExpr))) &void  (c.emit "(%s " (goBinaryOpToSchemeOp ((dot node.Op String)))) (c.emitExpr node.X) (c.emit " ") (c.emitExpr node.Y) (c.emit ")")) (func  #(c (ptr Compiler)) emitBlockStmt ( #(node (ptr ast.BlockStmt))) &void  (when (== node.List %nil)  (return)) (range (:= (_ stmt) node.List) (c.emit " ") (c.emitStmt stmt))) (func  #(c (ptr Compiler)) emitBranchStmt ( #(node (ptr ast.BranchStmt))) &void  (c.emit "(%s" ((dot node.Tok String))) (when (!= node.Label %nil)  (c.emit " %s" ((dot node.Label String)))) (c.emit ")")) (func  #(c (ptr Compiler)) emitCallExpr ( #(node (ptr ast.CallExpr))) &void  (c.emit "(") (when (!= node.Ellipsis 0)  (c.emit "apply... ")) (c.emitExpr node.Fun) (range (:= (_ arg) node.Args) (c.emit " ") (c.emitExpr arg)) (c.emit ")")) (func  #(c (ptr Compiler)) emitCaseClause ( #(node (ptr ast.CaseClause)) #(cond &bool)) &void  (when (or (== node.List %nil) (== (len node.List) 0))  (c.emit "(else ") (range (:= (_ stmt) node.Body) (c.emit " ") (c.emitStmt stmt)) (c.emit ")") (return)) (c.emit "(") (when cond  (c.emitExpr (index node.List 0))(else  (:= sep "(") (range (:= (_ expr) node.List) (c.emit sep) (c.emitExpr expr) (= sep " ")) (c.emit ")"))) (c.emit " ") (range (:= (_ stmt) node.Body) (c.emit " ") (c.emitStmt stmt)) (c.emit ")")) (func  #(c (ptr Compiler)) emitChanType ( #(node (ptr ast.ChanType))) &void  (c.emit "(chan") (case! node.Dir ((ast.RECV)  (c.emit "<-")) ((ast.SEND)  (c.emit "<-!"))) (c.emit " ") (c.emitType node.Value) (c.emit ")")) (func  #(c (ptr Compiler)) emitCommClause ( #(node (ptr ast.CommClause))) &void  (when (== node.Comm %nil)  (c.emit "(else")(else  (c.emit "(") (c.emitStmt node.Comm))) (when (!= node.Body %nil)  (range (:= (_ stmt) node.Body) (c.emit " ") (c.emitStmt stmt))) (c.emit ")")) (func  #(c (ptr Compiler)) emitComment ( #(node (ptr ast.Comment))) &void ) (func  #(c (ptr Compiler)) emitCommentGroup ( #(node (ptr ast.CommentGroup))) &void ) (func  #(c (ptr Compiler)) emitCompositeLit ( #(node (ptr ast.CompositeLit))) &void  (c.emit "#(") (c.emitType node.Type) (range (:= (_ arg) node.Elts) (c.emit " ") (c.emitExpr arg)) (c.emit ")")) (func  #(c (ptr Compiler)) emitDecl ( #(node ast.Decl)) &void  (type! (:= a (as node type)) (((ptr ast.GenDecl))  (c.emitGenDecl a)) (((ptr ast.FuncDecl))  (c.emitFuncDecl a)))) (func  #(c (ptr Compiler)) emitDeferStmt ( #(node (ptr ast.DeferStmt))) &void  (c.emit "(defer ") (c.emitCallExpr node.Call) (c.emit ")")) (func  #(c (ptr Compiler)) emitEmptyStmt ( #(node (ptr ast.EmptyStmt))) &void  (c.emit "#f")) (func  #(c (ptr Compiler)) emitExpr ( #(node ast.Expr)) &void  (when (== node %nil)  (return)) (type! (:= a (as node type)) (((ptr ast.BasicLit))  (c.emitBasicLit a)) (((ptr ast.CompositeLit))  (c.emitCompositeLit a)) (((ptr ast.Ellipsis))  (c.emitExpr a.Elt)) (((ptr ast.FuncLit))  (c.emitFuncLit a)) (((ptr ast.Ident))  (c.emitIdent a)) (((ptr ast.BinaryExpr))  (c.emitBinaryExpr a)) (((ptr ast.CallExpr))  (c.emitCallExpr a)) (((ptr ast.IndexExpr))  (c.emitIndexExpr a)) (((ptr ast.KeyValueExpr))  (c.emitKeyValueExpr a)) (((ptr ast.ParenExpr))  (c.emitExpr a.X)) (((ptr ast.SelectorExpr))  (c.emitSelectorExpr a)) (((ptr ast.SliceExpr))  (c.emitSliceExpr a)) (((ptr ast.StarExpr))  (c.emitStarExpr a)) (((ptr ast.TypeAssertExpr))  (c.emitTypeAssertExpr a)) (((ptr ast.UnaryExpr))  (c.emitUnaryExpr a)) (((ptr ast.ArrayType))  (c.emitArrayType a)) (((ptr ast.ChanType))  (c.emitChanType a)) (((ptr ast.FuncType))  (c.emitFuncType a)) (((ptr ast.InterfaceType))  (c.emitInterfaceType a)) (((ptr ast.MapType))  (c.emitMapType a)) (((ptr ast.StructType))  (c.emitStructType a)) (else  (c.emit "<expr:%v>" node)))) (func  #(c (ptr Compiler)) emitField ( #(node (ptr ast.Field))) &void  (when (== (len node.Names) 0)  (c.emitType node.Type) (return)) (c.emit "#(") (range (:= (_ name) node.Names) (c.emit "%s " (goIdToSchemeId name.Name))) (c.emitType node.Type) (c.emit ")")) (func  #(c (ptr Compiler)) emitFieldList ( #(node (ptr ast.FieldList))) &void  (range (:= (_ field) node.List) (c.emit " ") (c.emitField field))) (func  #(c (ptr Compiler)) emitFile ( #(node (ptr ast.File))) &void  (c.emit "(package ") (c.emitIdent node.Name) (range (:= (_ decl) node.Decls) (c.emit " ") (c.emitDecl decl)) (c.emit ")")) (func  #(c (ptr Compiler)) emitForStmt ( #(node (ptr ast.ForStmt))) &void  (when (and (== node.Init %nil) (== node.Post %nil))  (c.emit "(while ") (when (== node.Cond %nil)  (c.emit "#t")(else  (c.emitExpr node.Cond))) (c.emit " ") (c.emitBlockStmt node.Body) (c.emit ")") (return)) (c.emit "(for ") (when (== node.Init %nil)  (c.emit "#f")(else  (c.emitStmt node.Init))) (c.emit " ") (when (== node.Cond %nil)  (c.emit "#t")(else  (c.emitExpr node.Cond))) (c.emit " ") (when (== node.Post %nil)  (c.emit "#f")(else  (c.emitStmt node.Post))) (c.emit " ") (c.emitBlockStmt node.Body) (c.emit ")")) (func  #(c (ptr Compiler)) emitFuncDecl ( #(node (ptr ast.FuncDecl))) &void  (:= ellipsis #f) (when* (:= pars (dot (dot node.Type Params) List)) (and (!= pars %nil) (> (len pars) 0))  (:= last (index pars (- (len pars) 1))) (when* (:= (_ ok) (as last.Type (ptr ast.Ellipsis))) ok  (= ellipsis #t))) (c.emit "(func") (when ellipsis  (c.emit "...")) (when (!= node.Recv %nil)  (c.emit " ") (c.emitFieldList node.Recv)) (c.emit " ") (c.emitIdent node.Name) (c.emit " ") (c.emitFuncTypes node.Type #f) (c.emit " ") (c.emitBlockStmt node.Body) (c.emit ")")) (func  #(c (ptr Compiler)) emitFuncLit ( #(node (ptr ast.FuncLit))) &void  (c.emit "(func ") (c.emitFuncTypes node.Type #f) (c.emit " ") (c.emitBlockStmt node.Body) (c.emit ")")) (func  #(c (ptr Compiler)) emitFuncType ( #(node (ptr ast.FuncType))) &void  (c.emitFuncTypes node #t)) (func  #(c (ptr Compiler)) emitFuncTypes ( #(node (ptr ast.FuncType)) #(external &bool)) &void  (when external  (c.emit "(func ")) (c.emit "(") (c.emitFieldList node.Params) (c.emit ")") (c.emitFuncResults node.Results) (when external  (c.emit ")"))) (func  #(c (ptr Compiler)) emitFuncResults ( #(node (ptr ast.FieldList))) &void  (c.emit " ") (when (or (== node %nil) (== (len node.List) 0))  (c.emit "&void") (return)) (when (== (len node.List) 1)  (c.emitField (index node.List 0)) (return)) (c.emit "(values") (range (:= (_ field) node.List) (c.emit " ") (c.emitField field)) (c.emit ")")) (func  #(c (ptr Compiler)) emitGenDecl ( #(node (ptr ast.GenDecl))) &void  (when (== node.Tok token.IMPORT)  (c.emitImports node.Specs) (return)) (c.emit "(%s" ((dot node.Tok String))) (case! node.Tok ((token.TYPE)  (range (:= (_ spec) node.Specs) (c.emit " ") (c.emitTypeSpec (as spec (ptr ast.TypeSpec))))) ((token.CONST)  (fallthrough)) ((token.VAR)  (range (:= (_ spec) node.Specs) (c.emit " ") (c.emitValueSpec (as spec (ptr ast.ValueSpec)))))) (c.emit ")")) (func  #(c (ptr Compiler)) emitGoStmt ( #(node (ptr ast.GoStmt))) &void  (c.emit "(go ") (c.emitCallExpr node.Call) (c.emit ")")) (func  #(c (ptr Compiler)) emitIdent ( #(node (ptr ast.Ident))) &void  (c.emitRaw (goIdToSchemeId node.Name))) (func  #(c (ptr Compiler)) emitIfStmt ( #(node (ptr ast.IfStmt))) &void  (:= unless #f) (when* (:= (un ok) (as node.Cond (ptr ast.UnaryExpr))) ok  (when (== ((dot un.Op String)) "!")  (= unless #t))) (c.emit "(") (when unless  (c.emit "unless")(else  (c.emit "when"))) (when (!= node.Init %nil)  (c.emit "* ") (c.emitStmt node.Init)) (c.emit " ") (when unless  (c.emitExpr (dot (as node.Cond (ptr ast.UnaryExpr)) X))(else  (c.emitExpr node.Cond))) (c.emit " ") (c.emitBlockStmt node.Body) (when (!= node.Else %nil)  (c.emit "(else ") (type! (:= a (as node.Else type)) (((ptr ast.BlockStmt))  (c.emitBlockStmt a)) (else  (c.emitStmt node.Else))) (c.emit ")")) (c.emit ")")) (func  #(c (ptr Compiler)) emitImports ( #(any (interface ))) &void  (c.emit "(import") (type! (:= specs (as any type)) (((slice ast.Spec))  (range (:= (_ spec) specs) (c.emit " ") (c.emitImportSpec (as spec (ptr ast.ImportSpec))))) (((slice (ptr ast.ImportSpec)))  (range (:= (_ spec) specs) (c.emit " ") (c.emitImportSpec spec)))) (c.emit ")")) (func  #(c (ptr Compiler)) emitImportSpec ( #(node (ptr ast.ImportSpec))) &void  (when (!= node.Name %nil)  (when (== (dot node.Name Name) ".")  (c.emit "(dot ")(else  (c.emit "(as ") (c.emitIdent node.Name) (c.emit " "))) (c.emitBasicLit node.Path) (c.emit ")") (return)) (c.emitBasicLit node.Path)) (func  #(c (ptr Compiler)) emitIncDecStmt ( #(node (ptr ast.IncDecStmt))) &void  (c.emit "(%s " ((dot node.Tok String))) (c.emitExpr node.X) (c.emit ")")) (func  #(c (ptr Compiler)) emitIndexExpr ( #(node (ptr ast.IndexExpr))) &void  (c.emit "(index ") (c.emitExpr node.X) (c.emit " ") (c.emitExpr node.Index) (c.emit ")")) (func  #(c (ptr Compiler)) emitInterfaceType ( #(node (ptr ast.InterfaceType))) &void  (c.emit "(interface ") (c.emitFieldList node.Methods) (c.emit ")")) (func  #(c (ptr Compiler)) emitKeyValueExpr ( #(node (ptr ast.KeyValueExpr))) &void  (c.emit "(: ") (when* (:= (key ok) (as node.Key (ptr ast.BasicLit))) ok  (c.emitBasicLit key) (c.emit " ")(else (when* (:= (key ok) (as node.Key (ptr ast.Ident))) ok  (c.emit "%s " (goIdToSchemeId key.Name))(else  (panic "emitKeyValueExpr: expected string or identifier"))))) (c.emitExpr node.Value) (c.emit ")")) (func  #(c (ptr Compiler)) emitLabeledStmt ( #(node (ptr ast.LabeledStmt))) &void  (c.emit "(label %s " ((dot node.Label String))) (c.emitStmt node.Stmt) (c.emit ")")) (func  #(c (ptr Compiler)) emitMapType ( #(node (ptr ast.MapType))) &void  (c.emit "(map-type ") (c.emitType node.Key) (c.emit " ") (c.emitType node.Value) (c.emit ")")) (func  #(c (ptr Compiler)) emitRangeStmt ( #(node (ptr ast.RangeStmt))) &void  (c.emit "(range (%s " ((dot node.Tok String))) (when (== node.Value %nil)  (c.emitExpr node.Key)(else  (c.emit "(") (c.emitExpr node.Key) (c.emit " ") (c.emitExpr node.Value) (c.emit ")"))) (c.emit " ") (c.emitExpr node.X) (c.emit ")") (c.emitBlockStmt node.Body) (c.emit ")")) (func  #(c (ptr Compiler)) emitReturnStmt ( #(node (ptr ast.ReturnStmt))) &void  (c.emit "(return") (range (:= (_ arg) node.Results) (c.emit " ") (c.emitExpr arg)) (c.emit ")")) (func  #(c (ptr Compiler)) emitSelectStmt ( #(node (ptr ast.SelectStmt))) &void  (c.emit "(comm!") (range (:= (_ stmt) (dot node.Body List)) (c.emit " ") (c.emitCommClause (as stmt (ptr ast.CommClause)))) (c.emit ")")) (func  #(c (ptr Compiler)) emitSelectorExpr ( #(node (ptr ast.SelectorExpr))) &void  (when* (:= (id ok) (as node.X (ptr ast.Ident))) ok  (c.emit "%s.%s" (goIdToSchemeId id.Name) (goIdToSchemeId (dot node.Sel Name))) (return)) (c.emit "(dot ") (c.emitExpr node.X) (c.emit " %s)" (goIdToSchemeId (dot node.Sel Name)))) (func  #(c (ptr Compiler)) emitSendStmt ( #(node (ptr ast.SendStmt))) &void  (c.emit "(<-! ") (c.emitExpr node.Chan) (c.emit " ") (c.emitExpr node.Value) (c.emit ")")) (func  #(c (ptr Compiler)) emitSliceExpr ( #(node (ptr ast.SliceExpr))) &void  (c.emit "(index ") (c.emitExpr node.X) (c.emit " ") (when (== node.Low %nil)  (c.emit "#f")(else  (c.emitExpr node.Low))) (c.emit " ") (when (== node.High %nil)  (c.emit "#f")(else  (c.emitExpr node.High))) (c.emit ")")) (func  #(c (ptr Compiler)) emitStarExpr ( #(node (ptr ast.StarExpr))) &void  (c.emit "(ptr ") (c.emitType node.X) (c.emit ")")) (func  #(c (ptr Compiler)) emitStmt ( #(node ast.Stmt)) &void  (type! (:= a (as node type)) (((ptr ast.AssignStmt))  (c.emitAssignStmt a)) (((ptr ast.BlockStmt))  (c.emitBlockStmt a)) (((ptr ast.BranchStmt))  (c.emitBranchStmt a)) (((ptr ast.DeclStmt))  (c.emitDecl a.Decl)) (((ptr ast.DeferStmt))  (c.emitDeferStmt a)) (((ptr ast.EmptyStmt))  (c.emitEmptyStmt a)) (((ptr ast.ExprStmt))  (c.emitExpr a.X)) (((ptr ast.ForStmt))  (c.emitForStmt a)) (((ptr ast.GoStmt))  (c.emitGoStmt a)) (((ptr ast.IfStmt))  (c.emitIfStmt a)) (((ptr ast.IncDecStmt))  (c.emitIncDecStmt a)) (((ptr ast.LabeledStmt))  (c.emitLabeledStmt a)) (((ptr ast.RangeStmt))  (c.emitRangeStmt a)) (((ptr ast.ReturnStmt))  (c.emitReturnStmt a)) (((ptr ast.SelectStmt))  (c.emitSelectStmt a)) (((ptr ast.SendStmt))  (c.emitSendStmt a)) (((ptr ast.SwitchStmt))  (c.emitSwitchStmt a)) (((ptr ast.TypeSwitchStmt))  (c.emitTypeSwitchStmt a)) (else  (c.emit "<stmt:%v>" node)))) (func  #(c (ptr Compiler)) emitStructType ( #(node (ptr ast.StructType))) &void  (c.emit "(struct") (c.emitFieldList node.Fields) (c.emit ")")) (func  #(c (ptr Compiler)) emitSwitchStmt ( #(node (ptr ast.SwitchStmt))) &void  (:= cond (== node.Tag %nil)) (when cond  (c.emit "(cond!")(else  (c.emit "(case!"))) (when (!= node.Init %nil)  (c.emit "* ") (c.emitStmt node.Init)) (unless cond  (c.emit " ") (c.emitExpr node.Tag)) (range (:= (_ stmt) (dot node.Body List)) (c.emit " ") (c.emitCaseClause (as stmt (ptr ast.CaseClause)) cond)) (c.emit ")")) (func  #(c (ptr Compiler)) emitType ( #(node ast.Expr)) &void  (when* (:= (id ok) (as node (ptr ast.Ident))) ok  (c.emitRaw (goIdToSchemeId id.Name)) (return)) (c.emitExpr node)) (func  #(c (ptr Compiler)) emitTypeAssertExpr ( #(node (ptr ast.TypeAssertExpr))) &void  (c.emit "(as ") (c.emitExpr node.X) (c.emit " ") (when (== node.Type %nil)  (c.emit "type")(else  (c.emitType node.Type))) (c.emit ")")) (func  #(c (ptr Compiler)) emitTypeSpec ( #(node (ptr ast.TypeSpec))) &void  (c.emitIdent node.Name) (c.emit " ") (c.emitType node.Type)) (func  #(c (ptr Compiler)) emitTypeSwitchStmt ( #(node (ptr ast.TypeSwitchStmt))) &void  (c.emit "(type!") (when (!= node.Init %nil)  (c.emit "* ") (c.emitStmt node.Init)) (c.emit " ") (c.emitStmt node.Assign) (range (:= (_ stmt) (dot node.Body List)) (c.emit " ") (c.emitCaseClause (as stmt (ptr ast.CaseClause)) #f)) (c.emit ")")) (func  #(c (ptr Compiler)) emitUnaryExpr ( #(node (ptr ast.UnaryExpr))) &void  (c.emit "(%s " (goUnaryOpToSchemeOp ((dot node.Op String)))) (c.emitExpr node.X) (c.emit ")")) (func  #(c (ptr Compiler)) emitValueNames ( #(ids (slice (ptr ast.Ident)))) &void  (:= buffer #((slice &byte))) (range (:= (_ id) ids) (= buffer (append buffer #\ )) (= buffer (apply... append buffer (goIdToSchemeId id.Name)))) (when (== (len ids) 1)  (c.emit "%s" (&imm-string (index buffer 1 #f)))(else  (c.emit "(%s)" (&imm-string (index buffer 1 #f)))))) (func  #(c (ptr Compiler)) emitValueTypedNames ( #(ids (slice (ptr ast.Ident))) #(t ast.Expr)) &void  (:= buffer #((slice &byte))) (range (:= (_ id) ids) (= buffer (apply... append buffer (goIdToSchemeId id.Name))) (= buffer (append buffer #\ ))) (c.emit "#(%s" (&imm-string buffer)) (c.emitType t) (c.emit ")")) (func  #(c (ptr Compiler)) emitValueSpec ( #(node (ptr ast.ValueSpec))) &void  (when (!= node.Type %nil)  (when (!= node.Values %nil)  (c.emit "(= ") (c.emitValueTypedNames node.Names node.Type) (range (:= (_ arg) node.Values) (c.emit " ") (c.emitExpr arg)) (c.emit ")")(else  (c.emitValueTypedNames node.Names node.Type)))(else  (when (!= node.Values %nil)  (c.emit "(= ") (c.emitValueNames node.Names) (range (:= (_ arg) node.Values) (c.emit " ") (c.emitExpr arg)) (c.emit ")")(else  (c.emitValueNames node.Names)))))))