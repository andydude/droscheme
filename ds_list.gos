; -*- mode: scheme -*-
; (ds list) based on SRFI-1
(package droscheme

  (define-go ((ls (ptr Pair)) Ref (ka Any) Any)
	(:= k (ToFixnum ka))
    (for (:= cur (Any ls)) (IsPair cur) (= (k cur) (inline "k-1") (cdr cur))
         (if1 (== k 0)
              (return (car cur))))
	;(if1 (IsPair rest)
    ;     (return (void))) ; (car default?)
    (return (void)))

  (define (length a)
    (as a Seq (Length)))

  (define (list* z)
    (void))

  (define (list+ z)
    (void))

  (define (null? z)
    (void))
  (define (pair? z)
    (void))

  (define (alist-cons) (void))
  (define (alist-copy) (void))
  (define (alist-delete) (void))
  (define (alist-delete!) (void))
  (define (any) (void))
  (define (append!) (void))
  (define (append-map) (void))
  (define (append-map!) (void))
  (define (append-reverse) (void))
  (define (append-reverse!) (void))
  (define (assoc) (void))
  (define (break) (void))
  (define (break!) (void))

  (define-go (car+cdr (ls Any) 
      (values (car Any) (cdr Any)))
    (return (car ls) (cdr ls)))

  (define (car ls)
    (as ls (ptr Pair) car))

  (define (cdr ls)
    (as ls (ptr Pair) cdr))

  (define (caar ls) (car (car ls)))
  (define (cadr ls) (car (cdr ls)))
  (define (caaar ls) (car (cdr (cdr ls))))
  (define (caadr ls) (car (cdr (cdr ls))))
  (define (cadar ls) (car (cdr (cdr ls))))
  (define (caddr ls) (car (cdr (cdr ls))))
  (define (caaaar ls) (car (car (car (car ls)))))
  (define (caaadr ls) (car (car (car (cdr ls)))))
  (define (caadar ls) (car (car (cdr (car ls)))))
  (define (caaddr ls) (car (car (cdr (cdr ls)))))
  (define (cadaar ls) (car (cdr (car (car ls)))))
  (define (cadadr ls) (car (cdr (car (cdr ls)))))
  (define (caddar ls) (car (cdr (cdr (car ls)))))
  (define (cadddr ls) (car (cdr (cdr (cdr ls)))))
  (define (cdaaar ls) (cdr (car (car (car ls)))))
  (define (cdaadr ls) (cdr (car (car (cdr ls)))))
  (define (cdadar ls) (cdr (car (cdr (car ls)))))
  (define (cdaddr ls) (cdr (car (cdr (cdr ls)))))
  (define (cddaar ls) (cdr (cdr (car (car ls)))))
  (define (cddadr ls) (cdr (cdr (car (cdr ls)))))
  (define (cdddar ls) (cdr (cdr (cdr (car ls)))))
  (define (cddddr ls) (cdr (cdr (cdr (cdr ls)))))
  (define (cdaar ls) (cdr (car (car ls))))
  (define (cdadr ls) (cdr (car (cdr ls))))
  (define (cddar ls) (cdr (cdr (car ls))))
  (define (cdddr ls) (cdr (cdr (cdr ls))))
  (define (cdar ls) (cdr (car ls)))
  (define (cddr ls) (cdr (cdr ls)))

  (define (cons a b)
    (adr #(Pair a b)))

  (define (list . rest)
    (vector->list #(SVector rest)))

  (define (list-ref ls k . rest)
    (as ls (ptr Pair) (Ref k)))

  (define (set-car! ls value)
    (inline "ls.(*Pair).car = value")
    (void))

  (define (set-cdr! ls value)
    (inline "ls.(*Pair).cdr = value")
    (void))

  (define (circular-list) (void))
  (define (circular-list?) (void))
  (define (concatenate) (void))
  (define (concatenate!) (void))

  ;(define (cons* . rest)
  ;  (apply list* rest))

  (define (count) (void))
  (define (delete) (void))
  (define (delete!) (void))
  (define (delete-duplicates) (void))
  (define (delete-duplicates!) (void))
  (define (dotted-list?) (void))
  (define (drop) (void))
  (define (drop-right) (void))
  (define (drop-right!) (void))
  (define (drop-while) (void))
  (define (every) (void))
  (define (filter) (void))
  (define (filter!) (void))
  (define (filter-map) (void))
  (define (find) (void))
  (define (find-tail) (void))
  (define (fold) (void))
  (define (fold-right) (void))
  (define (iota) (void))
  (define (last) (void))
  (define (last-pair) (void))
  (define (length+) (void))

  (define (list-copy ls)
    (if1 (bool-not (IsPair ls))
         (return ls))
    (:= (car cdr) (car+cdr ls))
    (cons car (list-copy cdr)))
    ;(let loop ((ls ls))
    ;  (if (pair? ls)
    ;      (cons (car ls) (loop (cdr ls)))
    ;      ls)))

  (define (list-index) (void))
  (define (list-tabulate) (void))
  (define (list=) (void))
  (define (lset-adjoin) (void))
  (define (lset-diff+intersection) (void))
  (define (lset-diff+intersection!) (void))
  (define (lset-difference) (void))
  (define (lset-difference!) (void))
  (define (lset-intersection) (void))
  (define (lset-intersection!) (void))
  (define (lset-union) (void))
  (define (lset-union!) (void))
  (define (lset-xor) (void))
  (define (lset-xor!) (void))
  (define (lset<=) (void))
  (define (lset=) (void))
  (define (make-list) (void))
  (define (map!) (void))
  (define (map-in-order) (void))
  (define (member) (void))

  (define (not-pair? x)
    (not (pair? x)))

  (define (null)
    (call-go list0))

  (define (null-list?) (void))
  (define (pair-fold) (void))
  (define (pair-fold-right) (void))
  (define (pair-for-each) (void))
  (define (partition) (void))
  (define (partition!) (void))
  (define (reduce) (void))
  (define (reduce-right) (void))
  (define (remove) (void))
  (define (remove!) (void))
  (define (reverse!) (void))
  (define (span) (void))
  (define (span!) (void))
  (define (split-at) (void))
  (define (split-at!) (void))
  (define (take) (void))
  (define (take!) (void))
  (define (take-right) (void))
  (define (take-while) (void))
  (define (take-while!) (void))
  (define (unfold) (void))
  (define (unfold-right) (void))
  (define (unzip1) (void))
  (define (unzip2) (void))
  (define (unzip3) (void))
  (define (unzip4) (void))
  (define (unzip5) (void))

  (define (xcons a b)
    (cons b a))

  (define (zip) (void))

);package