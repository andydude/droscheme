#lang scribble/base

@title{Gos Programming Language}

@section{Introduction}

This is a reference manual for the Gos programming language.
Gos is an S-expressions syntax for Go, hence the name.
Most forms are exactly the same as Go with parentheses added,
however there are changes such as @tt{map} is written @tt{map:} 
and @tt{if} is written @tt{when} to allow syntactic sugar to be written 
that matches Scheme more closely.

The purpose of Gos is to write the standard library for Droscheme.

@subsection{Examples}

For example, the following Gos code:
@verbatim{
(func hypot (#(x y float64)) float64
  (return (math.Sqrt (+ (* x x) (* y y)))))
}
compiles to the Go code:
@verbatim{
func hypot(x, y float64) float64 {
  return math.Sqrt(x*x + y*y)
}
}

@section{Lexical syntax}

Source code is represented as S-expressions similar to Lisp and Scheme.

Almost every language construct is represented with lists, but there
is one language construct that is represented with vectors: typed identifiers.

@verbatim{
#(x y float32)           
#(a b c d IdentifierType)
}

@subsection{Identifiers}

Identifiers are encoded using the following system:
@verbatim{
ZA !     ZF &     ZK -     ZP <     ZS ?     ZX |
ZD $     ZH *     ZM /     ZQ =     ZT @"@"     ZY ~
ZE %     ZI +     ZN :     ZR >     ZV ^     ZZ Z
}
There are plans to encode @tt{.} as @tt{ZL} in the future, but not yet.
Gos identifiers have the same gamut as Scheme identifiers, and so you can
safely use any identifier you would like. They are encoded by the compiler
so that they do not collide with Go identifiers and keywords.

@subsection{Keywords}

There are several different kinds of keywords in Gos.
All of the keywords in this document are prefixed with @tt{go:} when
run by the compiler system.

The following are type-keywords:
@verbatim{
*               chan            interface
map:            chan<-          slice
array           chan<-!         struct
}

@nested[#:style 'inset
@itemlist[
@item{@tt{(*} @italic{type}@tt{)} represents pointer types.}
@item{@tt{(map:} @italic{keytype} @italic{type}@tt{)} represents map types.}
]]

The following are declaration-keywords:
@verbatim{
const           import          type
func            package         var
}

The @tt{func} keyword is the most polymorphic language construct in Gos.
@nested[#:style 'inset
@itemlist[

@item{@tt{(func} @italic{param} @italic{ret} ... @italic{body?}@tt{)} represents a
@nested[#:style 'inset
@itemlist[
@item{function type 
(@hyperlink[#:style "plainlink" "http://golang.org/ref/spec#FunctionType"]{FunctionType}) 
in a type context, and a}
@item{function literal
(@hyperlink[#:style "plainlink" "http://golang.org/ref/spec#FunctionLit"]{FunctionLit}) 
in an expression context.}
]]
The @italic{param} must be a list.}

@item{@tt{(func} @italic{name} @italic{param} @italic{ret} ... @italic{body?}@tt{)} represents a
@nested[#:style 'inset
@itemlist[
@item{method specification 
(@hyperlink[#:style "plainlink" "http://golang.org/ref/spec#MethodSpec"]{MethodSpec}) 
in an interface context, a}
@item{function declaration
(@hyperlink[#:style "plainlink" "http://golang.org/ref/spec#FunctionDecl"]{FunctionDecl}) 
in an declaration context, and a}
@item{function literal assigned to a var
(@hyperlink[#:style "plainlink" "http://golang.org/ref/spec#VarDecl"]{VarDecl}) 
in a statement context.

This is one feature required by all Schemes but is absent in Go; the ability to declare a named function that is local to the scope of the body of a function declaration.}
]]
The @italic{name} must be a symbol.}

@item{@tt{(func} @italic{receiver} @italic{name} @italic{param} @italic{ret}@tt{)} represents a method declaration
(@hyperlink[#:style "plainlink" "http://golang.org/ref/spec#MethodDecl"]{MethodDecl}) 
in a declaration context. 

The @italic{receiver} must be a vector.}
]]

The following are statement-keywords:
@verbatim{
++ -- <-! %= *= += -= /= := <<= >>= =

bitwise-and=        goto         
bitwise-or=         import        
bitwise-xor=        interface     
break               package       
continue            range         
default             return         
defer               select        
fallthrough         switch           
for                 type          
go                  var
}

Expressions may also include Types in Go, so these keywords may also appear in type-expressions.
The following are expression-keywords:
@verbatim{
!= ! % * & + - / < <- << <= == > >= >>

bitwise-and         as     
bitwise-or          dot     
bitwise-xor         index      
and                 index-set!
apply               or     
call                xor    
}

@subsection{Integer literals}

Integer literals are represented the same as they are in Go.

@subsection{Floating-point literals}

Floating-point literals are represented the same as they are in Go.
Imaginary literals are not supported.

@subsection{Character literals}

Characters are represented @tt["#\\"]@italic{char}.

@subsection{String literals}

Strings are represented @tt["\""]@italic{string}@tt["\""].

@section{Types}

@verbatim{
Type     = TypeName | TypeLit .
TypeName = QualifiedIdent .
TypeLit  = ArrayType
         | StructType
         | PointerType
         | FunctionType
         | InterfaceType
         | SliceType 
         | MapType 
         | ChannelType .
}

@subsection{Boolean types}

The boolean type is written @tt{bool} and has the values @tt["#t"] and @tt["#f"].

@subsection{Numeric types}

Numeric types have the same names as they do in Go.

@subsection{String types}

The string type is written @tt{string}.

@subsection{Array types}

Array types are written @tt["(array"] @italic{size} @italic{type}@tt[")"]

@verbatim{
ArrayType   = '(array' ArrayLength ElementType ')' .
ArrayLength = Expression .
ElementType = Type .
}

@subsection{Slice types}

@verbatim{
SliceType = '(slice' ElementType ')'
}

@subsection{Struct types}

Struct types represent a sequence of fields.

@verbatim{
StructType = '(struct' { FieldDecl } ')' .
FieldDecl  = TypedIdentifierList | Type .
}

If a @tt{TypedIdentifierList} includes no identifiers, then it represents an anonymous field, in which case the @tt{Type} is restricted to named types and pointers to named types. 

For example:
@verbatim{
; An empty struct.
(struct)

; A struct with 6 fields.
(struct
	#(x y int)
	#(u float32)
	#(_ float32) ; padding
	#(A (* (slice int)))
	#(F (func () void)))
}

@subsection{Pointer types}

@verbatim{
PointerType = '(*' Type ')' .
}

@subsection{Function types}

@verbatim{
FunctionType   = '(func' Signature ')'.
Signature      = { ParameterDecl } Result .
Result         = '(values' { ParameterDecl } ')' | 'void' | Type .
ParameterDecl  = TypedIdentifierList | Type .
}

One major difference between Go and Gos is that in Go the return type is optional, but in Gos the parameters are optional, and the return type is required. 

Ellipses are supported by using the @tt{ellipsis} keyword, which may be used with @tt{array} and @tt{func}.

@subsection{Interface types}
@verbatim{
InterfaceType      = '(interface' { MethodSpec } ')' .
MethodSpec         = '(func' MethodName Signature ')' 
                   | InterfaceTypeName .
MethodName         = Identifier .
InterfaceTypeName  = TypeName .
}

For example:
@verbatim{
(type (Lock (interface
	(func Lock void)
	(func Unlock void))))
}

@subsection{Map types}
@verbatim{
MapType     = '(map:' KeyType ElementType ')' .
KeyType     = Type .
}

@subsection{Channel types}
@verbatim{
ChannelType = '(' ChannelKind ElementType ')' .
ChannelKind = 'chan'
            | 'chan<-'
            | 'chan<-!' .
}

@section{Declarations}

@subsection{Constant declarations}
@verbatim{
ConstDecl = '(const' { ConstSpec } ')' .
ConstSpec = '(=' IdentifierList ExpressionList ')'
          | '(=' TypedIdentifierList ExpressionList ')'
          | Identifier .

TypedIdentifierList  = '#(' { Identifier } Type ')' .
IdentifierList       = '(' { Identifier } ')' .
ExpressionList       = { Expression } .
}

Iota is written @tt{iota}.

@subsection{Type declarations}
@verbatim{
TypeDecl = '(type' { TypeSpec } ')' .
TypeSpec = Identifier Type .
}

@subsection{Variable declarations}
@verbatim{
VarDecl = '(var { VarSpec } ')' .
VarSpec = '(=' IdentifierList ExpressionList ')'
        | '(=' TypedIdentifierList ExpressionList ')'
        | TypedIdentifierList .
}

@subsection{Short variable declarations}
@verbatim{
ShortVarDecl = '(:=' IdentifierList ExpressionList ')' .
}

@subsection{Function declarations}
@verbatim{
FunctionDecl = '(func' FunctionName Signature Body ')' .
FunctionName = Identifier .
Body         = { Statement } .
}

@subsection{Method declarations}
@verbatim{
MethodDecl = '(func' Receiver MethodName Signature Body ')' .
Receiver   = '#(' [ Identifier ] Type ')' .
}

@tt{Type} is restricted to named types or pointers to named types.

@section{Expressions}

@subsection{Operands}
@verbatim{
Operand  = Literal | QualifiedIdent | MethodExpr
Literal  = BasicLit | CompositeLit | FunctionLit .
BasicLit = int_lit | float_lit | imaginary_lit 
         | char_lit | string_lit .
}

@subsection{Qualified identifiers}
@verbatim{
QualifiedIdent = '(dot' { Identifier } Identifier ')' .
}
@tt{QualifiedIdent}s may also be written "id.id".

@subsection{Composite literals}
@verbatim{
CompositeLit  = '(make:' LiteralType LiteralValue ')'
              | '(new:' LiteralType LiteralValue ')' .
LiteralType   = StructType | ArrayType | SliceType | MapType | TypeName .
LiteralValue  = { Element } .
Element       = Value | '(:' Key Value ')' .
Key           = FieldName | ElementIndex .
FieldName     = Identifier .
ElementIndex  = Expression .
Value         = Expression | CompositeLit .
}

The two forms are syntactic sugar for two common composite literal expressions.
The @tt{make:} form represents @tt{Type@"{"Values@"}"}, and the @tt{new:} form
represents @tt{&Type@"{"Values@"}"}.

Given the declarations
@verbatim{
(type
  (Point3D (struct (x y z float64)))
  (Line (struct (p q Point3D))))
}
one may write
@verbatim{
(:= origin (make: Point3D)) ; zero value for Point3D
(:= line (make: Line origin (make: Point3D (: y -4) (: z 12.3))))
}

@subsection{Function literals}
@verbatim{
FunctionLit = '(func' Signature Body ')' .
}

@subsection{Primary expressions}
@verbatim{
PrimaryExpr = Operand
            | Conversion
            | BuiltinCall
            | Selector
            | Index
            | Slice
            | TypeAssertion
            | Call .
}

@subsection{Selectors}
@verbatim{
Selector = '(dot' PrimaryExpr Identifier ')'
         | Identifier '.' Identifier .
}

@subsection{Indexes and Slices}
@verbatim{
IndexSet = '(index-set!' PrimaryExpr Expression Expression ')' .
Index    = '(index' PrimaryExpr Expression ')' .
Slice    = '(index' PrimaryExpr OptExpr OptExpr ')' .
OptExpr  = '#f' | Expression .
}

@subsection{Type assertions}
@verbatim{
TypeAssertion = '(as' PrimaryExpr Type ')'
              | '(as' PrimaryExpr Type Call ')' .
}

@subsection{Calls}
@verbatim{
BuiltinId = 'new' | 'make'
BuiltinCall = '(' BuiltinId Type { ArgumentList } ')' .
Call = '(' PrimaryExpr { ArgumentList } ')'
     | '(call' PrimaryExpr { ArgumentList } ')'
     | '(apply' PrimaryExpr { ArgumentList } ')' .
ArgumentList = ExpressionList .
}

For example:
@verbatim{
(f a1 a2 â€¦ an)
(math.Atan2 x y)
(var #(pt (* Point)))
(pt.Scale 3.5)
}

@subsection{Operators}
@verbatim{
Expression = PrimaryExpr
           | '(' unary_op PrimaryExpr ')'
           | '(' binary_op Expression PrimaryExpr ')' .

binary_op  = 'or' | 'and' | rel_op | add_op | mul_op .
rel_op     = '==' | '!=' | '<' | '<=' | '>' | '>=' .
add_op     = '+' | '-' | 'bitwise-or' | 'bitwise-xor' .
mul_op     = '*' | '/' | '%' | '<<' | '>>' 
           | 'bitwise-and' | 'bitwise-but' .

unary_op   = '+' | '-' | 'not' | 'bitwise-not' 
           | '*' | '&' | '<-' .
}

@subsection{Arithmetic operators}
Arithmetic operators have the same spellings as they do in Go.

@subsection{Comparison operators}
Comparison operators have the same spellings as they do in Go.

@subsection{Logical operators}
Logical operators are spelled differently because of problems with OR.

@verbatim{
Go  Gos (Binary)
&   bitwise-and
&=  bitwise-and=
&&  and
||  or
|   bitwise-or
|=  bitwise-or=
^   bitwise-xor
^=  bitwise-xor=
&^  bitwise-but
&^= bitwise-but=

Go  Gos (Unary)
^   bitwise-not
!   not
}

@subsection{Address operators}
@verbatim{
'(&' Expression ')'
'(*' Expression ')'
}

For example:
@verbatim{
(& x)
(& (index a (f 2)))
(* p)
(* (pf x))
}

@subsection{Receive operator}
@verbatim{
'(<-' Expression ')'
}

For example:
@verbatim{
(= (x ok) (<- ch))
(:= (x ok) (<- ch))
(var (= (x ok) (<- ch)))
}

@subsection{Method expressions}
@verbatim{
MethodExpr    = '(dot' ReceiverType MethodName ')' .
ReceiverType  = TypeName | '(*' TypeName ')' .
}

@subsection{Conversions}
@verbatim{
Conversion = '(call' Type Expression ')' .
}

@section{Statements}
@verbatim{
Statement = Declaration | LabeledStmt | SimpleStmt | GoStmt 
          | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt 
          | SwitchStmt | SelectStmt | ForStmt | DeferStmt
          | FallthroughStmt | Block | IfStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt 
           | Assignment | ShortVarDecl .
}
The @tt{Statement} production is the same as in Go.

@subsection{Labeled statements}
@verbatim{
(label name)
}

@subsection{Expression statements}
@verbatim{
ExpressionStmt = Expression .
}
The @tt{ExpressionStmt} production is the same as in Go.

@subsection{Send statements}
@verbatim{
SendStmt = '(<-!' Channel Expression ')' .
Channel  = Expression .
}

@subsection{IncDec statements}
@verbatim{
(++ x)
(-- x)
}

@subsection{Assignments}
@verbatim{
Assignment = '(' assign_op '(' ExpressionList ')' ExpressionList ')' .
assign_op  = [ add_op | mul_op ] '=' .
}

@subsection{If statements}
@verbatim{
IfStmt   = '(when' Expression Block [ ElseStmt ] ')'
         | '(when*' OptStmt Expression Block [ ElseStmt ] ')'
         | '(unless' Expression Block [ ElseStmt ] ')'
         | '(unless*' OptStmt Expression Block [ ElseStmt ] ')' .
OptStmt  = '#f' | SimpleStmt
ElseStmt = '(else' Block ')' .
Block    = { Statement } .
}

@subsection{Switch statements}
@verbatim{
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
}

@verbatim{
ExprSwitchStmt = '(cond!' { CondClause } ')'
               | '(cond!*' SimpleStmt { CondClause } ')'
               | '(case!' Expression { CaseClause } ')'
               | '(case!*' SimpleStmt Expression { CaseClause } ')' .
CondClause     = '(' Expression Block ')' | '(else' Block ')' .
CaseClause     = '((' ExpressionList ')' Block ')' 
               | '(else' Block ')' .
}

@verbatim{
TypeSwitchStmt  = '(type!' TypeGuard { TypeClause } ')'
                | '(type!*' SimpleStmt TypeGuard { TypeClause } ')' .
TypeGuard       = '(as' PrimaryExpr 'type)' .
                | '(:=' Identifier '(as' PrimaryExpr 'type))' .
TypeClause      = '((' TypeList ')' Block ')' 
                | '(else' Block ')' .
TypeList        = Type { Type } .
}

@subsection{For statements}
@verbatim{
ForStmt     = '(while' Condition Block ')'
            | '(range' RangeClause Block ')'
            | '(for' ForClause Block ')' .

Condition   = '#t' | Expression .
ForClause   = OptStmt Condition OptStmt .
RangeClause = '(=' IdentifierList Expression ')'
            | '(:=' IdentifierList Expression ')' .
}

@subsection{Go statements}
@verbatim{
GoStmt = '(go' Expression ')' .
}

@subsection{Select statements}
@verbatim{
SelectStmt = '(comm!' { CommClause } ')' .
CommClause = '(' CommStmt Block ')'
           | '(else' Block ')' .
CommStmt   = SendStmt | RecvStmt
RecvStmt   = '(:=' ExpressionList RecvExpr ')' .
RecvExpr   = Expression .
}

@subsection{Return statements}
@verbatim{
ReturnStmt = '(return' ExpressionList ')' .
}

@subsection{Break statements}
@verbatim{
BreakStmt = '(break' [ Label ] ')' .
}

@subsection{Continue statements}
@verbatim{
ContinueStmt = '(continue' [ Label ] ')' .
}

@subsection{Goto statements}
@verbatim{
GotoStmt = '(goto' Label ')' .
}

@subsection{Fallthrough statements}
@verbatim{
FallthroughStmt = '(fallthrough)' .
}

@subsection{Defer statements}
@verbatim{
DeferStmt = '(defer' Expression ')' .
}


@section{Packages}
@verbatim{
SourceFile = '(' PackageClause { ImportDecl } { TopLevelDecl } ')' .
}

@subsection{Package clause}
@verbatim{
PackageClause = 'package' PackageName .
PackageName   = Identifier .
}

@subsection{Import declarations}
@verbatim{
ImportDecl = '(import' { ImportSpec } ')' .
ImportSpec = '(as' PackageName ImportPath ')'
           | '(dot' ImportPath ')'
           | ImportPath .
ImportPath = string_lit .
}
