#lang scribble/manual

@title{Gos Programming Language}

@section{Introduction}

This is a reference manual for the Gos programming language.
Gos is an S-expressions syntax for Go, hence the name.
Most forms are exactly the same as Go with parentheses added,
however there are changes such as @tt{map} is written @tt{map-type} 
and @tt{if} is written @tt{when} to allow syntactic sugar to be written 
that matches Scheme more closely.

The purpose of Gos is to write the standard library for Droscheme.

@subsection{Examples}

For example, the following Gos code:
@verbatim{
(func hypot (#(x y &float64)) &float64
  (return (math.Sqrt (+ (* x x) (* y y)))))
}
compiles to the Go code:
@verbatim{
func hypot(x, y float64) float64 {
  return math.Sqrt(x*x + y*y)
}
}

@section{Lexical syntax}

Source code is represented as S-expressions similar to Lisp and Scheme.

Almost every language construct is represented with lists, but there
are two language constructs that are represented with vectors.
In an expression context, vectors represent composite literals,
and in a declaration context, vectors represent typed identifiers.

@verbatim{
#(x y int)                         ; declaration context
#(a b c d IdentifierType)          ; declaration context
#(LiteralType a b c d e f)         ; expression context
#(LiteralType #:author a #:book b) ; expression context
}

@subsection{Identifiers}

@subsection{Keywords}

There are several different kinds of keywords in Gos.

The following are type-keywords:
@verbatim{
----------------++++++++++++++++----------------
array           func-type       slice
chan            interface       struct
chan<-          map-type
chan<-!         ptr 
}

The following are declaration-keywords:
@verbatim{
define-const    define-type     package
define-func     define-var
define-init     import    
}

The following are statement-keywords:
@verbatim{
++ -- <-! %= *= += -= /= := <<= >>= =

bitwise-and=
bitwise-but=
bitwise-or=
bitwise-xor=
}

  ...

The following are expression-keywords:
@verbatim{
!= ! % * + - / < <- << <= == > >= >>

bitwise-and
bitwise-but
bitwise-or
bitwise-xor
}


@verbatim{
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
adr
and
as
but
ior
xor
call
dot
index
index-set!
lambda-func
ptr

}

@subsection{Integer literals}

Integer literals are represented the same as they are in Go.

@subsection{Floating-point literals}

Floating-point literals are represented the same as they are in Go.
Imaginary literals are not supported.

@subsection{Character literals}

Characters are represented @tt["#\\"]@italic{char}.

@subsection{String literals}

Strings are represented @tt["\""]@italic{string}@tt["\""].

@section{Types}

@verbatim{
Type     = TypeName | TypeLit .
TypeName = QualifiedIdent .
TypeLit  = ArrayType
         | StructType
         | PointerType
         | FunctionType
         | InterfaceType
         | SliceType 
         | MapType 
         | ChannelType .
}

@subsection{Boolean types}

The boolean type is written @tt{&bool} and has the values @tt["#t"] and @tt["#f"].

@subsection{Numeric types}

Numeric types have the same names as they do in Go, prefixed with an ampersand (@tt{&}).

@subsection{String types}

The string type is written @tt{&imm-string}.

@subsection{Array types}

Array types are written @tt["(array"] @italic{size} @italic{type}@tt[")"]

@verbatim{
ArrayType   = '(array' ArrayLength ElementType ')' .
ArrayLength = Expression .
ElementType = Type .
}

@subsection{Slice types}

@verbatim{
SliceType = '(slice' ElementType ')'
}

@subsection{Struct types}

Struct types represent a sequence of fields.

@verbatim{
StructType = '(struct' { FieldDecl } ')' .
FieldDecl  = TypedIdentifierList | Type .
}

If a @tt{TypedIdentifierList} includes no identifiers, then it represents an anonymous field, in which case the @tt{Type} is restricted to named types and pointers to named types. 

For example:
@verbatim{
; An empty struct.
(struct)

; A struct with 6 fields.
(struct
	#(x y &int)
	#(u &float32)
	#(_ &float32) ; padding
	#(A (ptr (slice &int)))
	#(F (func () &void)))
}

@subsection{Pointer types}

@verbatim{
PointerType = '(ptr' Type ')' .
}

@subsection{Function types}

@verbatim{
FunctionType   = '(func' Signature ')'.
Signature      = { ParameterDecl } Result .
Result         = '(values' { ParameterDecl } ')' | '&void' | Type .
ParameterDecl  = TypedIdentifierList | Type .
}

One major difference between Go and Gos is that in Go the return type is optional, but in Gos the parameters are optional, and the return type is required. 

Ellipses are not supported.

@subsection{Interface types}
@verbatim{
InterfaceType      = '(interface' { MethodSpec } ')' .
MethodSpec         = '(func' MethodName Signature ')' 
                   | InterfaceTypeName .
MethodName         = Identifier .
InterfaceTypeName  = TypeName .
}

For example:
@verbatim{
(define-type (Lock (interface
	(func Lock &void)
	(func Unlock &void))))
}

@subsection{Map types}
@verbatim{
MapType     = '(map-type' KeyType ElementType ')' .
KeyType     = Type .
}

@subsection{Channel types}
@verbatim{
ChannelType = '(' ChannelKind ElementType ')' .
ChannelKind = 'chan'
            | 'chan<-'
            | 'chan<-!' .
}

@section{Declarations}

@subsection{Constant declarations}
@verbatim{
ConstDecl = '(const' { ConstSpec } ')' .
ConstSpec = '(=' IdentifierList ExpressionList ')'
          | '(=' TypedIdentifierList ExpressionList ')'
          | Identifier .

TypedIdentifierList  = '#(' { Identifier } Type ')' .
IdentifierList       = '(' { Identifier } ')' .
ExpressionList       = { Expression } .
}

Iota is written @tt{iota}.

@subsection{Type declarations}
@verbatim{
TypeDecl = '(type' { TypeSpec } ')' .
TypeSpec = '(' Identifier Type ')' .
}

@subsection{Variable declarations}
@verbatim{
VarDecl = '(var { VarSpec } ')' .
VarSpec = '(=' IdentifierList ExpressionList ')'
        | '(=' TypedIdentifierList ExpressionList ')'
        | TypedIdentifierList .
}

@subsection{Short variable declarations}
@verbatim{
ShortVarDecl = '(:=' IdentifierList ExpressionList ')' .
}

@subsection{Function declarations}
@verbatim{
FunctionDecl = '(func' FunctionName Signature Body ')' .
FunctionName = Identifier .
Body         = { Statement } .
}

@subsection{Method declarations}
@verbatim{
MethodDecl = '(func' Receiver MethodName Signature Body ')' .
Receiver   = '#(' [ Identifier ] Type ')' .
}

@tt{Type} is restricted to named types or pointers to named types.

@section{Expressions}

@subsection{Operands}
@verbatim{
Operand  = Literal | QualifiedIdent | MethodExpr
Literal  = BasicLit | CompositeLit | FunctionLit .
BasicLit = int_lit | float_lit | imaginary_lit 
         | char_lit | string_lit .
}

@subsection{Qualified identifiers}
@verbatim{
QualifiedIdent = '(dot' { Identifier } Identifier ')' .
}
@tt{QualifiedIdent}s may also be written "id.id".

@subsection{Composite literals}
@verbatim{
CompositeLit  = '#(' LiteralType LiteralValue ')' .
LiteralType   = StructType | ArrayType | SliceType | MapType | TypeName .
LiteralValue  = { Element } .
Element       = Value | '(:' Key Value ')' .
Key           = FieldName | ElementIndex .
FieldName     = Identifier .
ElementIndex  = Expression .
Value         = Expression | CompositeLit .
}

Given the declarations
@verbatim{
(type
  (Point3D (struct (x y z &float64)))
  (Line (struct (p q Point3D))))
}
one may write
@verbatim{
(:= origin #(Point3D)) ; zero value for Point3D
(:= line #(Line origin #(Point3D (: y -4) (: z 12.3))))
}

@subsection{Function literals}
@verbatim{
FunctionLit = '(func' Signature Body ')' .
}

@subsection{Primary expressions}
@verbatim{
PrimaryExpr = Operand
            | Conversion
            | BuiltinCall
            | Selector
            | Index
            | Slice
            | TypeAssertion
            | Call .
}

@subsection{Selectors}
@verbatim{
Selector = '(dot' PrimaryExpr Identifier ')'
         | Identifier '.' Identifier .
}

@subsection{Indexes and Slices}
@verbatim{
Index   = '(index' PrimaryExpr Expression ')' .
Slice   = '(index' PrimaryExpr OptExpr OptExpr ')' .
OptExpr = '#f' | Expression .
}

@subsection{Type assertions}
@verbatim{
TypeAssertion = '(as' PrimaryExpr Type ')'
              | '(as' PrimaryExpr Type Call ')' .
}

@subsection{Calls}
@verbatim{
BuiltinCall = '(' Type { ArgumentList } ')' .
Call = '(' PrimaryExpr { ArgumentList } ')'
     | '(apply' PrimaryExpr { ArgumentList } ')'
     | '(apply...' PrimaryExpr { ArgumentList } ')' .
ArgumentList = ExpressionList .
}

For example:
@verbatim{
(f a1 a2 â€¦ an)
(math.Atan2 x y)
(define-var (pt) (ptr Point))
(dot pt (Scale 3.5))
}

@subsection{Operators}
@verbatim{
Expression = PrimaryExpr
           | '(' unary_op PrimaryExpr ')'
           | '(' binary_op Expression PrimaryExpr ')' .

binary_op  = 'or' | 'and' | rel_op | add_op | mul_op .
rel_op     = '==' | '!=' | '<' | '<=' | '>' | '>=' .
add_op     = '+' | '-' | 'bitwise-or' | 'bitwise-xor' .
mul_op     = '*' | '/' | '%' | '<<' | '>>' 
           | 'bitwise-and' | 'bitwise-but' .

unary_op   = '+' | '-' | 'not' | 'bitwise-not' 
           | 'ptr' | 'adr' | '<-' .
}

@subsection{Arithmetic operators}
Arithmetic operators have the same spellings as they do in Go.

@subsection{Comparison operators}
Comparison operators have the same spellings as they do in Go.

@subsection{Logical operators}
Logical operators are spelled differently because of problems with OR.

@verbatim{
Go  Gos (Binary)
&   bitwise-and
&=  bitwise-and=
&&  and
||  or
|   bitwise-or
|=  bitwise-or=
^   bitwise-xor
^=  bitwise-xor=
&^  bitwise-but
&^= bitwise-but=

Go  Gos (Unary)
^   bitwise-not
!   not
}

@subsection{Address operators}
@verbatim{
'(adr' Expression ')'
'(ptr' Expression ')'
}

For example:
@verbatim{
(adr x)
(adr (index a (f 2)))
(ptr p)
(ptr (pf x))
}

@subsection{Receive operator}
@verbatim{
'(<-' Expression ')'
}

For example:
@verbatim{
(= (x ok) (<- ch))
(:= (x ok) (<- ch))
(define-var (= (x ok) (<- ch)))
}

@subsection{Method expressions}
@verbatim{
MethodExpr    = '(apply' ReceiverType MethodName ')' .
ReceiverType  = TypeName | '(ptr' TypeName ')' .
}

@subsection{Conversions}
@verbatim{
Conversion = '(' Type Expression ')' .
}

@section{Statements}
@verbatim{
Statement = Declaration | LabeledStmt | SimpleStmt | GoStmt 
          | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt 
          | SwitchStmt | SelectStmt | ForStmt | DeferStmt
          | FallthroughStmt | Block | IfStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt 
           | Assignment | ShortVarDecl .
}
The @tt{Statement} production is the same as in Go.

@subsection{Labeled statements}
@verbatim{
(label name)
}

@subsection{Expression statements}
@verbatim{
ExpressionStmt = Expression .
}
The @tt{ExpressionStmt} production is the same as in Go.

@subsection{Send statements}
@verbatim{
SendStmt = '(<-!' Channel Expression ')' .
Channel  = Expression .
}

@subsection{IncDec statements}
@verbatim{
(++ x)
(-- x)
}

@subsection{Assignments}
@verbatim{
Assignment = '(' assign_op '(' ExpressionList ')' ExpressionList ')' .
assign_op  = [ add_op | mul_op ] '=' .
}

@subsection{If statements}
@verbatim{
IfStmt   = '(when' Expression Block [ ElseStmt ] ')'
         | '(when*' OptStmt Expression Block [ ElseStmt ] ')'
         | '(unless' Expression Block [ ElseStmt ] ')'
         | '(unless*' OptStmt Expression Block [ ElseStmt ] ')' .
OptStmt  = '#f' | SimpleStmt
ElseStmt = '(else' Block ')' .
Block    = { Statement } .
}

@subsection{Switch statements}
@verbatim{
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
}

@verbatim{
ExprSwitchStmt = '(cond!' { CondClause } ')'
               | '(cond!*' SimpleStmt { CondClause } ')'
               | '(case!' Expression { CaseClause } ')'
               | '(case!*' SimpleStmt Expression { CaseClause } ')' .
CondClause     = '(' Expression Block ')' | '(else' Block ')' .
CaseClause     = '((' ExpressionList ')' Block ')' 
               | '(else' Block ')' .
}

@verbatim{
TypeSwitchStmt  = '(type!' TypeGuard { TypeClause } ')'
                | '(type!*' SimpleStmt TypeGuard { TypeClause } ')' .
TypeGuard       = '(as' PrimaryExpr 'type)' .
                | '(:=' Identifier '(as' PrimaryExpr 'type))' .
TypeClause      = '((' TypeList ')' Block ')' 
                | '(else' Block ')' .
TypeList        = Type { Type } .
}

@subsection{For statements}
@verbatim{
ForStmt     = '(while' Condition Block ')'
            | '(range' RangeClause Block ')'
            | '(for' ForClause Block ')' .

Condition   = '#t' | Expression .
ForClause   = OptStmt Condition OptStmt .
RangeClause = '(=' IdentifierList Expression ')'
            | '(:=' IdentifierList Expression ')' .
}

@subsection{Go statements}
@verbatim{
GoStmt = '(go' Expression ')' .
}

@subsection{Select statements}
@verbatim{
SelectStmt = '(comm!' { CommClause } ')' .
CommClause = '(' CommStmt Block ')'
           | '(else' Block ')' .
CommStmt   = SendStmt | RecvStmt
RecvStmt   = '(:=' ExpressionList RecvExpr ')' .
RecvExpr   = Expression .
}

@subsection{Return statements}
@verbatim{
ReturnStmt = '(return' ExpressionList ')' .
}

@subsection{Break statements}
@verbatim{
BreakStmt = '(break' [ Label ] ')' .
}

@subsection{Continue statements}
@verbatim{
ContinueStmt = '(continue' [ Label ] ')' .
}

@subsection{Goto statements}
@verbatim{
GotoStmt = '(goto' Label ')' .
}

@subsection{Fallthrough statements}
@verbatim{
FallthroughStmt = '(fallthrough)' .
}

@subsection{Defer statements}
@verbatim{
DeferStmt = '(defer' Expression ')' .
}


@section{Packages}
@verbatim{
SourceFile = '(' PackageClause { ImportDecl } { TopLevelDecl } ')' .
}

@subsection{Package clause}
@verbatim{
PackageClause = 'package' PackageName .
PackageName   = Identifier .
}

@subsection{Import declarations}
@verbatim{
ImportDecl = '(import' { ImportSpec } ')' .
ImportSpec = '(as' PackageName ImportPath ')'
           | '(dot' ImportPath ')'
           | ImportPath .
ImportPath = string_lit .
}
